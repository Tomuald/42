#+title: Webserv_implementation

This is where I'll implement my webserver in C++98.

* makefile
#+name: makefile
#+headers: :tangle ./Makefile
#+begin_src makefile
NAME	    =	program

HEAD	    =	srcs/configuration/Configuration.class.hpp \
		    srcs/server/Server.class.hpp \

SRCS	    =	srcs/configuration/Configuration.class.cpp \
		    srcs/server/Server.class.cpp \

OBJS	    =	${SRCS:.cpp=.o}

CFLAGS	=	-Wall -Wextra -Werror -std=c++98 -g

CC		=	c++

RM		=	rm -Rf

all:		${NAME}

${NAME}:	${SRCS} srcs/main.cpp
			${CC} ${CFLAGS} srcs/main.cpp ${SRCS} -o ${NAME}

clean:
			${RM} ${OBJS}

fclean:      clean
		    ${RM} ${NAME}

re:          fclean all

.PHONY: all clean fclean re
#+end_src
* main

The main gets launched with a config file.
#+name: main
#+headers: :tangle ./srcs/main.cpp :mkdirp yes
#+begin_src C++
#include "configuration/Configuration.class.hpp"

int main(int argc, char **argv, char **envp) {
  if (argc != 2) {
    return (-1);
  }

  (void) envp;
  // parse the config file
  Configuration config;
  config.init(argv[1]);
  // spin up the webserver
    // do webserver things somewhere else

  // stop the webserver when you're done

  return (0);
}

// document_root /var/www/html
#+end_src

* server class
#+name: server-hpp
#+header: :tangle ./srcs/server/Server.class.hpp :mkdirp yes
#+begin_src C++
#include <string>
#include <netinet/in.h>

class Server {
  public:
    Server(void);
    Server(Server const & src);
    ~Server(void);

    Server & operator=(Server const & rhs);
  private:
    std::string _hostname;
    in_addr_t   _ip_address;
    std::string _root;
    std::string _error_page;
    int         _max_body_size;
    bool        _directory_listing_status;
    std::string _cgi_format[2];
};
#+end_src

#+name: server-cpp
#+header: :tangle ./srcs/server/Server.class.cpp :mkdirp yes
#+begin_src C++
#include "Server.class.hpp"

Server::Server() {}
Server::~Server() {}
#+end_src
* request handler class
* configuration class

#+name: configuration-hpp
#+headers: :tangle ./srcs/configuration/Configuration.class.hpp :mkdirp yes
#+begin_src c++

#include <fstream>
#include <map>

#include "../server/Server.class.hpp"

class Configuration {
  public:
    Configuration(void);
    Configuration(Configuration const & src);
    ~Configuration(void);

    void init(const char *path);
    Configuration & operator=(Configuration const & rhs);
  private:
  // attributes
    std::fstream    _configuration_file;
    int             _numServers;
    Server          *servers;


  // functions
    int parse(void);
    int verify(void);
    void getNumServers(void);
    std::map<std::string, std::string> *getServerBlocks(void);
};

std::ostream & operator<<(std::ostream & o, Configuration & i);
#+end_src

I've allowed for multiple server blocks. I parse the file into a
std::vector that contains all of the information for a server block. I
also created a server class. My Config class has an array of servers.

Now, I can use my std::vector server_blocks to generate my Server
objects. You need to rename your Server objects to ServerConfig or
something along those lines because you'll have to implement an actual
Server class that runs stuff; as opposed to simply holding
information.


#+name: configuration-cpp
#+headers: :tangle ./srcs/configuration/Configuration.class.cpp :mkdirp yes
#+begin_src c++
#include "Configuration.class.hpp"

#include <fstream>
#include <string>
#include <iostream>
#include <map>
#include <vector>
#include <sstream>

Configuration::Configuration(void) {
  this->_numServers = 0;
}

Configuration::~Configuration(void) {
  if (this->_configuration_file.is_open())
    this->_configuration_file.close();
  delete [] servers;
}

void Configuration::init(const char *path) {
  if (!path)
    return ;
  try {
    this->_configuration_file.open(path);
    if (!this->_configuration_file.is_open())
      throw std::exception();
    else {
      getNumServers();
      this->servers = new Server[this->_numServers];
      parse();
      verify();
    }
  } catch (std::exception e) {
    std::cout << e.what() << std::endl;
  }
}

void Configuration::getNumServers(void) {
  std::string   line;
  bool          inside_server_block;

  inside_server_block = false;
  while (std::getline(this->_configuration_file, line)) {
    if (line.find("{") != std::string::npos && line.find("server") != std::string::npos) {
      inside_server_block = true;
      this->_numServers++;
      continue;
    }
    if (inside_server_block && line.find("}") != std::string::npos) {
      inside_server_block = false;
    }
  }
  this->_configuration_file.clear();
  this->_configuration_file.seekg(0, std::ios::beg);
}

std::map<std::string, std::string> *Configuration::getServerBlocks(void) {
  std::map<std::string, std::string> *server_blocks;
  std::string   line;
  bool          inside_server_block;
  int           index;

  inside_server_block = false;
  server_blocks = new std::map<std::string, std::string>[this->_numServers];
  index = 0;
  while (std::getline(this->_configuration_file, line)) {
    if (line.find("{") != std::string::npos && line.find("server") != std::string::npos) {
      inside_server_block = true;
      continue;
    }
    if (inside_server_block && line.find("}") != std::string::npos) {
      inside_server_block = false;
      index++;
    }
    if (inside_server_block && line.find("location") != std::string::npos) {
      std::string location_block;

      while (line.find("}") != std::string::npos) {
        std::getline(this->_configuration_file, location_block);
      }
    }
    if (inside_server_block) {
      std::vector<std::string> tokens;
      std::istringstream iss(line);

      std::string token;
      while (iss >> token) {
        tokens.push_back(token);
      }
      if (tokens.size() >= 2)
        server_blocks[index].insert(std::make_pair(tokens[0], tokens[1]));
      else {
        if (tokens.size() == 1)
          server_blocks[index].insert(std::make_pair(tokens[0], ""));
        else if (tokens.size() == 0)
          server_blocks[index].insert(std::make_pair("", ""));
        else
          std::cout << "unexpected case" << std::endl;
      }
    }
  }
  return (server_blocks);
}

int Configuration::parse(void) {
  // std::map<std::string, void (Configuration::*)(std::string)> settings;
  // std::map<std::string, void (Configuration::*)(std::string)>::iterator it;
  std::string               line;
  std::map<std::string, std::string>  *server_blocks;

  server_blocks = getServerBlocks();
  if (server_blocks->size() == 0)
    return (-1);
  for (int i = 0; i < this->_numServers; i++) {
    std::map<std::string, std::string>::iterator it;

    std::cout << "Server #" << i << std::endl;
    for (it = server_blocks[i].begin(); it != server_blocks[i].end(); it++) {
      std::cout << "Key: " << it->first << ", Value: " << it->second << std::endl;
    }
    std::cout << std::endl;
  }

  delete [] server_blocks;
  this->_configuration_file.close();
  return (0);
}

int Configuration::verify(void) {return (0);}
#+end_src
