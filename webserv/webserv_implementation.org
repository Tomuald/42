#+title: Webserv_implementation

This is where I'll implement my webserver in C++98.

* main

The main gets launched with a config file.
#+name: main
#+headers: :tangle ./srcs/main.cpp :mkdirp yes
#+begin_src C++
#include "configuration/Configuration.class.hpp"

int main(int argc, char **argv, char **envp) {
  if (argc != 2) {
    return (-1);
  }

  (void) envp;
  // parse the config file
  Configuration config;
  config.init(argv[1]);
  // spin up the webserver
    // do webserver things somewhere else

  // stop the webserver when you're done

  return (0);
}

// document_root /var/www/html
#+end_src

* server class
#+name: server-hpp
#+header: :tangle ./srcs/server/Server.class.hpp :mkdirp yes
#+begin_src C++
#include <string>
#include <netinet/in.h>

class Server {
  public:
    Server(void);
    Server(Server const & src);
    ~Server(void);

    Server & operator=(Server const & rhs);
  private:
    std::string _hostname;
    in_addr_t   _ip_address;
    std::string _root;
    std::string _error_page;
    int         _max_body_size;
    bool        _directory_listing_status;
    std::string _cgi_format[2];
};
#+end_src

#+name: server-cpp
#+header: :tangle ./srcs/server/Server.class.cpp :mkdirp yes
#+begin_src C++
#include "Server.class.hpp"

Server::Server() {}
Server::~Server() {}
#+end_src
* request handler class
* configuration class

#+name: configuration-hpp
#+headers: :tangle ./srcs/configuration/Configuration.class.hpp :mkdirp yes
#+begin_src c++

#include <fstream>
#include <map>

#include "../server/Server.class.hpp"

class Configuration {
  public:
    Configuration(void);
    Configuration(Configuration const & src);
    ~Configuration(void);

    void init(const char *path);
    Configuration & operator=(Configuration const & rhs);
  private:
  // attributes
    std::fstream    _configuration_file;
    int             _numServers;
    Server          *servers;


  // functions
    int parse(void);
    int verify(void);
    void getNumServers(void);
    std::map<std::string, std::string> *getServerBlocks(void);
};

std::ostream & operator<<(std::ostream & o, Configuration & i);
#+end_src

I've allowed for multiple server blocks. I parse the file into a
std::vector that contains all of the information for a server block. I
also created a server class. My Config class has an array of servers.

Now, I can use my std::vector server_blocks to generate my Server
objects.

#+name: configuration-cpp
#+headers: :tangle ./srcs/configuration/Configuration.class.cpp :mkdirp yes
#+begin_src c++
#include "Configuration.class.hpp"

#include <fstream>
#include <string>
#include <iostream>
#include <map>
#include <vector>
#include <sstream>

Configuration::Configuration(void) {
  this->_numServers = 0;
}

Configuration::~Configuration(void) {
  if (this->_configuration_file.is_open())
    this->_configuration_file.close();
  delete [] servers;
}

void Configuration::init(const char *path) {
  if (!path)
    return ;
  try {
    this->_configuration_file.open(path);
    if (!this->_configuration_file.is_open())
      throw std::exception();
    else {
      getNumServers();
      this->servers = new Server[this->_numServers];
      parse();
      verify();
    }
  } catch (std::exception e) {
    std::cout << e.what() << std::endl;
  }
}

void Configuration::getNumServers(void) {
  std::string   line;
  bool          inside_server_block;

  while (std::getline(this->_configuration_file, line)) {
    if (line.find("{") != std::string::npos && line.find("server") != std::string::npos) {
      inside_server_block = true;
      this->_numServers++;
      continue;
    }
    if (inside_server_block && line.find("}") != std::string::npos) {
      inside_server_block = false;
    }
  }
  this->_configuration_file.clear();
  this->_configuration_file.seekg(0, std::ios::beg);
}

std::map<std::string, std::string> *Configuration::getServerBlocks(void) {
  std::map<std::string, std::string> *server_blocks;
  std::string   line;
  bool          inside_server_block;
  int           index;

  server_blocks = new std::map<std::string, std::string>[this->_numServers];
  index = 0;
  while (std::getline(this->_configuration_file, line)) {
    if (line.find("{") != std::string::npos && line.find("server") != std::string::npos) {
      inside_server_block = true;
      continue;
    }
    if (inside_server_block && line.find("}") != std::string::npos) {
      inside_server_block = false;
      index++;
    }
    if (inside_server_block) {
      std::string::size_type pos = line.find_first_not_of(" \t");

      if (pos != std::string::npos) {
        std::string newtoken = line.substr(pos);
        std::vector<std::string> tokens;
        std::istringstream iss(newtoken);
        std::string token;
        while (std::getline(iss, token, ' '))
            tokens.push_back(token);
        server_blocks[index].insert(std::make_pair(tokens[0], tokens[1]));
      }
    }
  }
  return (server_blocks);
}

int Configuration::parse(void) {
  // std::map<std::string, void (Configuration::*)(std::string)> settings;
  // std::map<std::string, void (Configuration::*)(std::string)>::iterator it;
  std::string               line;
  std::map<std::string, std::string>  *server_blocks;

  server_blocks = getServerBlocks();

  for (int i = 0; i < this->_numServers; i++) {
    std::map<std::string, std::string>::iterator it;
    for (it = server_blocks[i].begin(); it != server_blocks[i].end(); it++) {
      std::cout << "Key: " << it->first << ", Value: " << it->second << std::endl;
    }
  }

  delete [] server_blocks;
  this->_configuration_file.close();
  return (0);
}

int Configuration::verify(void) {return (0);}
#+end_src
