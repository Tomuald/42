#+title: Exam04

Aight... so this seems to be working! It's actually pretty concise,
and straightforward. Make sure you understand the closing of pipes.

If you wanna clean it up a bit, combine *input & *output in a int[2].

also: implement CD, and make sure it works!!

#+header: :tangle ./microshell.c
#+begin_src C
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/wait.h>

#define PIPEOUT 1
#define PIPEIN 2
#define OUT 3
#define IN 4

void ft_print(char *string1, char *string2, int fd) {
  int i;

  if (!string1)
    return ;
  i = 0;
  while (string1[i])
    write(fd, &string1[i++], 1);
  i = 0;
  if (string2) {
      while (string2[i])
        write(fd, &string2[i++], 1);
      write(fd, "\n", 1);
  }
  return ;
}

void    ft_cd(char **argv) {
  int i;

  i = 0;
  while (argv[i])
    i++;
  if (i != 2) {
    ft_print("error: cd: bad arguments\n", NULL, 2);
    return ;
  }
  if (chdir(argv[1]) != 0)
    ft_print("error: cd: cannot change directory to ", argv[1], 2);
}

void execute(char **argv, char **envp, int IO[2]) {
  pid_t pid;
  int pipefd[2];

  if (pipe(pipefd) < 0)
    return ;
  pid = fork();
  if (pid < 0)
    return ;
  if (pid == 0) {
    // child
    close(pipefd[0]);
    if (IO[1] == PIPEOUT)
      dup2(pipefd[1], STDOUT_FILENO);
    close(pipefd[1]);
    if (strcmp(argv[0], "cd") == 0)
      ft_cd(argv);
    else if (execve(argv[0], argv, envp) < 0) {
      ft_print("error: cannot execute ", argv[0], 2);
      exit(1);
    }
  }
  else {
    // parent
    waitpid(pid, NULL, 0);
    close(pipefd[1]);
    if (IO[0] == PIPEIN)
      dup2(pipefd[0], STDIN_FILENO);
    close(pipefd[0]);
  }
  return ;
}

int parse(char **argv, int *output) {
  int i;

  i = 0;
  while (argv[i]) {
    if (strcmp(argv[i], "|") == 0) {
      argv[i] = NULL;
      (*output) = PIPEOUT;
      return (i);
    }
    if (strcmp(argv[i], ";") == 0) {
      argv[i] = NULL;
      (*output) = OUT;
      return (i);
    }
    i++;
  }
  (*output) = OUT;
  return (i);
}

int main(int argc, char **argv, char **envp) {
  int i;
  int offset;
  int IO[2];

  if (argc < 2) {
    ft_print("too few arguments\n", NULL, 2);
    return (-1);
  }
  i = 1;
  IO[0] = IN;
  while (i < argc && argv[i]) {
    offset = parse(&argv[i], &IO[1]);
    if (IO[1] == PIPEOUT && i != 0)
      (IO[0]) = PIPEIN;
    execute(&argv[i], envp, IO);
    i += offset;
    if (i + 1 < argc)
      i++;
  }
  return (0);
}
#+end_src
