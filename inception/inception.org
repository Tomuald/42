#+title: Inception
#+PROPERTY: header-args :noweb yes
DEADLINE: <2023-02-05 Sun>

#+GITHUB: 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

The purpose of this project is to create a LEMP infrastructure of
Docker services. LEMP refers to a collection of open-source software
that is commonly used together to serve web applications. The term
LEMP is an acronym that represents the configuration of a Linux
operating system with an nginx (pronounced engine-x, hence the E in
the acronym) web server, with site data stored in a MySQL database and
dynamic content processed by PHP.

Some useful links for the project:
 1) Tutorials
    1) [[https://github.com/NEKuipers/Inception/blob/master/Inception_guide.txt][NEKuipers]]
    2) [[https://github.com/vbachele/Inception][vbachele]]
    3) [[https://github.com/twagger/inception][twagger]]
 2) Ressources
    1) [[https://kapeli.com/cheat_sheets/Dockerfile.docset/Contents/Resources/Documents/index][docker cheatsheet]]
    2) [[https://discord.com/channels/831591290311409738/964254222105346048][additional links]]

* Table of Contents :TOC:
- [[#requirements][Requirements]]
- [[#research--development][Research & Development]]
  - [[#virtual-machine][virtual machine]]
  - [[#docker][docker]]
  - [[#environment-variables-setup][environment variables setup]]
  - [[#nginx][nginx]]
  - [[#wordpress][wordpress]]
  - [[#mariadb][mariadb]]
  - [[#docker-compose-network][docker-compose network]]
  - [[#docker-compose-volumes][docker-compose volumes]]

* Requirements
*Rules:*
 1) The infrastructure MUST run inside a VM, and thus, MUST use
    ~docker-compose~.
 2) Each docker image must be named after the service
 3) Each service must run inside its dedicated container
 4) The containers must run under Alpine Linux or Debian Buster
 5) Each container must contain a handmade Dockerfile
 6) Every Dockerfile must be called inside a ~docker-compose.yml~,
    which is itself called by the Makefile.
 7) Containers must reboot if a crash occurs
 8) The WordPress database must contain two user accounts:
    1) the Admin (username cannot contain "Admin|admin"")
 9) The use of "network: host", "--link", and "links" is forbidden.
    1) the line "network(s)" must be found in the "docker-compose.yml".
 10) The containers CANNOT be run in an infinite loop.
     1) forbidden hacky patches: tail -f, bash, sleep infinity, while
        true, ...
 11) Your domain name...
     1) must be: <login>.42.fr
     2) must point to your local IP address
 12) The "latest" tag is forbidden (~FROM debian:latest~ in a Dockerfile)
 13) Passwords must NEVER be written in your Dockerfiles
 14) You MUST use environment variables
 15) The use of a ~.env~ file to store envvars is strongly suggested
     (it should be kept at the root of the srcs directory)
 16) The NGINX container must be the sole entrypoint of the
     infrastructure, through port 443 ONLY, and using TLS v1.2 or 1.3

*Required Services:*
 1) 3 Containers that run, respectively:
    1) NGINX with TLS (v1.2 or 1.3)
    2) Wordpress + php-fpm (installed and configured; without NGINX)
    3) MariaDB (without NGINX)
 2) 2 Volumes that contain, respectively:
    1) a WordPress database
    2) files for the WordPress website
 3) A ~docker-network~ that links between containers

*A few suggestions:*
 1) Research proper Dockerfile syntax, and the "PID1"
 2) Look at the Diagram from the PDF, it is helpful!
 3) Look at the folder structure from the PDF
* Research & Development
** virtual machine
First off, build a VM with a GUI (you'll need a GUI to open a web
browser, and display an html page). Use debian. It's already on the
school computers.

Remember to do a barebones install; some default system services
(iptables, namely) make it incredibly complicated to set up the SSH
connection. Follow [[https://www.golinuxcloud.com/ssh-into-virtualbox-vm/][this guide]] to get SSH working without a hitch. Once
that's set up, work from your host OS: it is way more efficient. On a
side note, why are VirtualBox guest OSes so slow? even with a ton of
vRAM...

I'm still stuck with a NAT IP address, but everything seems to work
smoothly. I tested with another computer, and everything seems to run
A-OK!

Also, there's some trickery to use docker without sudo... e.g.: adding
your user to the sudoers group, and to the sudoers file; you can look
up this [[https://stackoverflow.com/questions/48957195/how-to-fix-docker-got-permission-denied-issue][stackoverflow thread]] for the procedure.

Then, install Docker.

** docker
Docker has pretty good documentation. You can find the [[https://docs.docker.com/engine/install/debian/#install-using-the-repository][installation
instructions here]]. Follow this guide properly, and everything should
set up easily. These instructions are valid as of today, 2023-01-08.

Remember that you need sudo privileges to run the following commands.

Start by installing requisites for docker:
#+begin_src bash
sudo apt-get update

sudo apt-get install ca-certificates curl gnupg lsb-release
sudo apt-get install docker-compose
#+END_SRC

Then, add Docker's GPG key, and set up the repository:
#+begin_src bash
sudo mkdir -p /etc/apt/keyrings

curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
#+end_src

Install Docker Engine, and Docker Compose, both are necessary for the project:
#+begin_src bash
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
#+end_src

Hopefully, you set up your VM with enough space; docker requires
~500MB of space.

Load up an image designed for testing to ensure that everything
installed properly:
#+begin_src bash
docker run hello-world
#+end_src

*** useful commands
#+begin_src bash
docker build <folder> # builds the image from Dockerfile
docker run <image> # run the docker image
    -d # run container in background
    -p # publish a container's port to the host
docker image kill <image> # stop a running image
docker image rm -f # force delete the image
#+end_src

*** dockerfiles
Dockerfiles are Makefiles for docker images. They are text documents
that contain instructions (keywords defined by docker), and commands
(bash or docker). The format is simple:
#+begin_src dockerfile
# Comment
INSTRUCTION arguments
#+end_src

Any instruction in the Dockerfile operates on its respective
container. i.e.: if you install something, it installs it your
container's filesystem! To have a look around a container, use the
~docker exec -t -i <containerID> /bin/bash~ command.

Multiline commands can be written by escaping the newline with ~\~.

Noteworthy instructions:
 1) FROM: The FROM instruction sets the base image used for subsequent
    instructions. A Dockerfile MUST start with this instruction. You
    can build composite images by adding more FROM keywords. See the
    [[https://docs.docker.com/engine/reference/builder/#from][docs]] for more info. i.e.: ~FROM <image>:<tag>~.
 2) ARG: ARG is used to declare variables within the Dockerfile which
    can reused anywhere in the subsequent code. BEWARE! an ARG defined
    before a FROM is "outside of a build stage, so it can't be used in
    any instruction after a FROM". i.e.: ~ARG variable=value~.
 3) RUN: RUN allows you to execute shell commands in a new layer on
    top of the image, and commit the results. This new image will be
    used for the next instructions. i.e.: ~RUN <command>~.
 4) CMD: The main purpose of a CMD is to provide defaults for an
    executing containers. There can be only one CMD in a Dockerfile.
    There are two forms for CMD instructions: shell form, and exec
    form. The second is preferred, and is expressed as a JSON array.
    i.e.: ~CMD ["/usr/bin/wc", "--help"]~.
 5) EXPOSE: EXPOSE informs Docker that the container listens of the
    specified network ports. You can specify TCP or UDP (TCP is the
    default). EXPORE doesn't publish the port, it functions as
    documentation, mainly... To expose the port, add the ~-p~ flag on
    ~docker run~. i.e.: ~EXPOSE 80/udp~
 6) ENV: ...
 7) ADD: ...
 8) COPY: COPY copies files or directories from <src>, and adds them
    to the filesystem of the container at the path <dest>. You can use
    Go's [[https://golang.org/pkg/path/filepath#Match][filepath.Match]] rules to use wildcards.
 9) ENTRYPOINT: allows you to configure a container that will run as
    an executable. Use the (preferred) exec form: ~ENTRYPOINT
    ["executable", "param1", "param2"]~.
 10) WORKDIR: sets the working directory for any ~RUN, CMD,
     ENTRYPOINT, COPY~, and ~ADD~ instructions. You can set it
     multiple times.

*** docker-compose
Docker-compose make building containers easier.
#+name: nginx-compose
#+begin_src docker-compose
version: '3'

services:
  nginx:
    container_name: nginx
    build: ./srcs/requirements/nginx/
    ports:
      - 443:443
    volumes:
      - wordpress_data:/var/www/html/
    networks:
      - network
#+end_src

Call this docker-compose file with: ~docker compose -f
docker-compose.yml up -d --build~. This runs the build process, and
spins up the nginx container.

*** docker-network
See this [[https://www.aquasec.com/cloud-native-academy/docker-container/docker-networking/][aqua tutorial]], and the links at the bottom of the page.

** environment variables setup
Sensitive data used by the db and wordpress should be kept safely
stored in a ~.env~ file.

In your root directory, add the following file:
#+name: .env-config-dev
#+begin_src text
MYSQL_ROOT_PASSWORD=inception
MYSQL_USER=tgarriss
MYSQL_PASSWORD=tgarriss
#+end_src

Make sure that you ignore this file in both your ~.gitignore~ and
~.dockerignore~ files.
** nginx
Nginx (pronounced engine-x), is a FLOSS web server. Why NGINX instead
of Apache? Because it uses much less memory, can handle about 4 times
as many requests per second, is highly scalable, has a modular,
event-driven architecture; it also works as a load balancer, and HTTP
cache, and a reverse proxy. This comes at the cost of decreased
flexibility (such as being unable to override systemwide access
settings).

[[https://business-science.github.io/shiny-production-with-aws-book/https-nginx-docker-compose.html][This]] might be useful; [[https://www.baeldung.com/linux/nginx-docker-container][this]] seems even better.

*** binding localhost to domain
Binding your domain name (<login>.42.fr, for this project) to your
localhost is easy. Simply add "127.0.0.1 localhost <domain-name>" to
your VM's ~/etc/hosts~ file.

*** a simple setup
WARNING: This works for a docker-compose.yml configured with port 80,
not 443! It is meant as a simple example:
#+begin_src dockerfile
FROM debian:buster

RUN apt-get update -y && apt-get -y install nginx

COPY ./nginx.conf /etc/nginx/conf.d/
COPY ./index.html /var/www/html/

CMD ["/usr/sbin/nginx", "-g", "daemon off;"]
#+end_src

Assuming you have your custom nginx config, and an html file in your
current directory:
 1) Pull the img
 2) update and install nginx
 3) copy the files to wherever you want them in your container
 4) start up nginx

If everything went ok, you can log into your VM, launch firefox, and
access your domain name; it should display your index.html webpage.

*** enabling https
Now, for enabling https support (using port 443, instead of port 80).
#+name: nginx-dockerfile-dev
#+begin_src dockerfile
# pull the debian:buster image
FROM debian:buster

RUN apt-get update -y
RUN apt-get -y install nginx openssl
# this installs php and php7.3-fpm
RUN apt-get -y install php php7.3-fpm

# required; if inexistant, openssl call raises an error
RUN mkdir /etc/nginx/ssl/
RUN openssl req -x509 -nodes -days 365 \
        -newkey rsa:2048 \
        -keyout /etc/nginx/ssl/tgarriss.key \
        -out /etc/nginx/ssl/tgarriss.csr \
        -subj "/C=CA/ST=QC/L=Thomas/O=42Quebec/OU=tgarriss/CN=tgarriss"

# replace this with your actual conf path
COPY nginx.conf /etc/nginx/conf.d/

# exposes the 443 port (the HTTPS port)
EXPOSE 443

CMD ["/usr/sbin/nginx", "-g", "daemon off;"]
#+end_src

The ~-subj~ flag is used to bypass prompts. See the digicert [[https://www.digicert.com/kb/ssl-support/openssl-quick-reference-guide.htm][website]]
for more info. With ~EXPOSE 443~, the webpage won't load, because
there's no certificate yet.

Now, the subject requires that we use ssl certificates. That requires
us to write a custom nginx configuration file. We're gonna generate
our certs with openssl; they're gonna be self-signed, which means
untrusted by web browsers unless approved by a certificate authority
(for the purpose of the project, this a self-signed certificate is
fine). This [[https://stackoverflow.com/questions/10175812/how-to-generate-a-self-signed-ssl-certificate-using-openssl][stackoverflow thread]] has some good information about it.
This [[https://www.digitalocean.com/community/tutorials/how-to-create-a-self-signed-ssl-certificate-for-nginx-on-debian-10][tutorial]] might come in handy too; have a look there's a lot of
info about self-signed certificates.

TSL (Transport Security Layer) and SSL (Secure Sockets Layer) are web
protocols that wrap normal traffic in a protected, encrypted wrapper.
These protocols use a combination of public and private keys. The SSL
key is kept secret on the server, and is used to encrypt content sent
to clients. The SSL certificate is publicly shared with anyone who
requests the content, and decrypts the content signed by the
associated SSL key.

- [X] exposes port 443y
- [X] installs openssl
- [X] generates certificates
- [X] configures openssl
- [-] has a nginx config file
  - [X] listens on port 443
  - [X] uses TLS v1.2 and v1.3
  - [ ] other things... ???
*** nginx config
WARNING: Remember that you'll be using wordpress to display a
website... there's somekind of interaction here that's missing.
Otherwise, my simple index.html webpage is displayed on https.

#+name: nginx-config-dev
#+begin_src text
server {
  # ssl specifies that it should use ssl
  listen 443 ssl;
  # the [::]: means any ipv6 addr
  listen [::]:443 ssl;
  server_name tgarriss.42.fr;

  # sets the cert/key pair and enables TLS
  ssl_certificate /etc/nginx/ssl/tgarriss.csr;
  ssl_certificate_key /etc/nginx/ssl/tgarriss.key;
  ssl_protocols TLSv1.2 TLSv1.3;

  root /var/www/html/;
  index index.html;
  location / {
		try_files $uri $uri/ /index.php$is_args$args;
	}
}
#+end_src
*** fast-cgi
This is required for interaction with wordpress, and mariadb.
** wordpress
Wordpress is a content management system (CMS). It requires a web
server (nginx), a database (mariadb), and PHP (php-fpm) in order to
function.

*** wordpress docker-compose
#+name: wordpress-compose
#+begin_src docker-compose
  wordpress:
    container_name: wordpress
    depends_on:
      - mariadb
    build:
      context: ./requirements/wordpress
      dockerfile: Dockerfile
    env_file:
      - .env
    volumes:
      - wordpress_data:/var/www/html/
    networks:
      - network
#+end_src

*** wordpress dockerfile
Now for the wordpress Dockerfile...
#+name: wp-dockerfile-dev
#+begin_src dockerfile
FROM debian:buster

RUN apt-get -y update && apt-get -y install php-fpm php-mysql
RUN apt-get -y install curl
WORKDIR /tmp/
RUN curl -LO https://wordpress.org/latest.tar.gz
RUN tar -xzvf latest.tar.gz
RUN cp /tmp/wordpress/wp-config-sample.php /tmp/wordpress/wp-config.php
#+end_src

In order to configure wordpress programatically (this needs to be done
because you'll be booting up a new instance of your containers every
time, and don't wanna go through the install process manually), you'll
need to use ~wp core / wp cli~. Check out [[https://developer.wordpress.org/cli/commands/core/install/][this tutorial]].

** mariadb
mariadb is necessary for wordpress to function properly. I've been
trying to chunk this down into managable pieces, but it's all
connected together.

*** mariadb docker-compose
#+name: mariadb-compose
#+begin_src docker-compose
  mariadb:
    container_name: mariadb
    build: ./requirements/mariadb
    volumes:
      - mariadb_data:/var/lib/mariadb/
    networks:
      - network
    env_file:
      - .env
#+end_src
*** mariadb dockerfile
#+name: db-dockerfile-dev
#+begin_src dockerfile
FROM debian:buster

RUN apt-get update
#+end_src
** docker-compose network
#+name: network-compose
#+begin_src docker-compose
networks:
  network:
    driver: bridge
#+end_src
** docker-compose volumes
#+name: volume-compose
#+begin_src docker-compose
volumes:
  mariadb_data:
    driver: local
    driver_opts:
      type: none
      device: /home/tgarriss/data/mariadb
      o: bind
  wordpress_data:
    driver: local
    driver_opts:
      type: none
      device: /home/tgarriss/data/wordpress
      o: bind
#+end_src
* Production :noexport:
** docker-compose
#+name: full-docker-compose
#+header: :tangle ./srcs/docker-compose.yml :noweb yes
#+begin_src dockerfile
<<nginx-compose>>

<<mariadb-compose>>

<<wordpress-compose>>

<<volume-compose>>

<<network-compose>>
#+end_src
** Dockerfiles
#+name: nginx-dockerfile
#+header: :tangle ./srcs/requirements/nginx/Dockerfile
#+header: :noweb yes
#+begin_src dockerfile
<<nginx-dockerfile-dev>>
#+end_src

#+name: wp-dockerfile
#+header: :tangle ./srcs/requirements/wordpress/Dockerfile
#+header: :noweb yes
#+begin_src dockerfile
<<wp-dockerfile-dev>>
#+end_src

#+name: db-dockerfile
#+header: :tangle ./srcs/requirements/mariadb/Dockerfile
#+header: :noweb yes
#+begin_src dockerfile
<<db-dockerfile-dev>>
#+end_src
** nginx.conf
#+name: nginx-config
#+header: :tangle ./srcs/requirements/nginx/nginx.conf
#+header: :noweb yes
#+begin_src text
<<nginx-config-dev>>
#+end_src
** .env file
#+name: .env-config
#+header: :tangle ./srcs/.env
#+header: :noweb yes
#+begin_src text
<<.env-config-dev>>
#+end_src
** makefile
#+name: makefile
#+header: :tangle ./Makefile
#+begin_src makefile
all:
	docker compose -f ./srcs/docker-compose.yml up -d --build

down:
	docker compose -f ./scrs/docker-compose.yml down

clean:
	docker stop $$(docker ps -qa);\
	docker rm $$(docker ps -qa);\
	docker image rm $$(docker images -qa);\

.PHONY: all down clean
#+end_src
