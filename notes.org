:PROPERTIES:
#+title: Notes
:END:

A collection of notes concerning 42 Projects.

* C++
** files & extensions
Files in cpp use the .cpp/.hpp extensions. It makes it easier for
compilators usually. When defining or declaring a class inside a file,
use: <NAME>.class.cpp/.hpp.
** classes
A basic class is declared in an .hpp file, like this:

#+NAME: basic-class-declare
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
class Sample
{
public:
  Sample(void);
  ~Sample(void);
};
#+END_SRC

Sample() and ~Sample() are the class's constructor and destructor.
They both have no return type, since they are procedures and not
really functions. The constructor is called as soon as you instanciate
a class. If defined locally, the class's destructor is called when the
function reaches it return() call.

#+NAME: basic-class-define
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
#include "Sample.class.hpp"

Sample::Sample(void)
{
  return ;
}

Sample::~Sample(void)
{
  return ;
}
#+END_SRC

To initialize an instance of class:
#+NAME: basic-class-instance
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
#include "Sample.class.hpp"

int main(int argc, char **argv)
{
  Sample    instance;

  return (0);
}
#+END_SRC

Instances of a class are simple: they're like any other old variable
or struct; they're objects; think of the mold/cake allegory.
** member attributes and functions
These are variables and functions defined in the body of a class.

#+NAME: member-attr-func
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
// Sample.class.hpp
class Sample(void)
{
public:
  Sample();
  ~Sample();

  int i;
  int is_active(void);
};

// Sample.class.cpp
#include "Sample.class.hpp"

// Constructor()
// ~Destructor()

// See section of the this-> keyword.
int Sample::is_active(void)
{
  if (this->i)
    return (1);
  return (0);
}

// main.c
#include "Sample.class.hpp"

int main(void)
{
  Sample instance;

  instance.i = 1;
  instance.is_active();
  return (0);
}
#+END_SRC
** this-> keyword
The this-> keyword is a pointer to the current instance. It's useful when defining a class. Take a basic class:

#+NAME: basic-this
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
class Sample
{
public:
  Sample(void);
  ~Sample(void);
  int i;
  int c;
  int set_c(void);
};
#+END_SRC

#+NAME: basic-this-2
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
#include "Sample.class.hpp"

Sample::Sample(void)
{
  this->i = 42;
  set_c();
  return ;
}

int Sample::set_c(void)
{
  this->c = 24;
  return (0);
}
#+END_SRC
** initialization lists
Initialization lists allow you to succintly setup variables during a
class's construction. Given the class below:

#+NAME: init-lists
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
// Sample.class.hpp
class Sample
{
public:
  char a1;
  int a2;
  float a3;

  Sample(char p1, int p2, float p3);
  ~Sample(void);
};

// Sample.class.cpp
#include "Sample.class.hpp"

Sample::Sample(char p1, int p2, float p3) : a1(p1), a2(p2), a3(p3)
{
  return ;
}
#+END_SRC

The format ~: a1(p1), a2(p2), a3(p3)~ sets the variable aX to the
value pX implicitly.

Initialization lists can be much more complex than this. We'll dive
into more detail later on.
** const keyword
const keywords are great. They allow to set values that will NEVER be
allowed to be modified or assigned to. It might be the difference
between a working program and a program that fucks up royally. Make
sure to use these keywords freely when writing C++ code; it will make
it more robust, and harder to break.

Be mindful of where the const keyword goes though!
  1) ~const int i~ declares a constant integer
  2) ~const int * i2 || int const * i2~ declares a variable pointer to a const integer
  3) ~int * const i3~ declares a constant pointer to a variable integer
  4) ~int const * const i2~ declares a constant pointer to a constant integer
  5) ~class Sample{ void function() const}~ declares that the member
     function 'function' CANNOT modify the values of the class.

Since const variables can NEVER be assigned a value, if we're working
in a class, we need to bypass that by initializing them with the same
concept of [[initialization lists][initialization lists]].

#+NAME: const-init
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp
class Sample
{
public:
  float const pi;
  int qd;

  Sample(float const f);
  ~Sample(void);

  void bar(void) const;
};

// Sample.class.cpp
Sample::Sample(float const f) : pi(f)
{
  return ;
}

void Sample::bar(void) const
{
  return ;
}
#+END_SRC

The difference is subtle, but here, we are INITIALIZING the variable,
not assigning to them.

We snuck in a const somewhere in the .hpp that might seem unusual:
~void bar(void) const~. This const applies to the function itself, and
means that NOWHERE in it's body will there be any type of assignation
to the members attributes of the class (no ~this->a = 42~, etc).
** static keyword
The static keyword in C++ can be found in a few places:
  1) as a ~static <type> var~ outside of a class. i.e., that it gets
     allocated memory for the lifetime of the program. Just like in C,
     this variable persists through function calls.
  2) as a ~static <type> var~ inside of a class. i.e., they are init'd
     once, and are allocated memory in static storage (!contiguous to
     the class); each instance share the same memory location, and
     value.
  3) as static member variables... Come back to this later.
** visibility (public vs private)
public vs private keywords restrain which attributes/functions are
accessible from within and outside the class. Private attrs/fcts are
INnaccesible from outside the class; whereas public ones can be
accessed from anywhere. Basically, think of the public attrs as the
ones that your user can access, and private ones as the ones your code
can access.

There is a convention to use the underscore (_var || var _) to
highlight private attributes. Its purpose is to make the code easier
to read, and understand at a glance, which is private, which is
public.

#+NAME: visibility
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
class Sample
{
private:
  const int i;
public:
  Sample(void);
  ~Sample(void);
};
#+END_SRC
** accessors
accessors are functions that allow to retrieve the values of your
private attributes (get() and set() functions).

Naming conventions are get<Attrb>(), set<Attrb>().

#+NAME: accessors
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample
{
public:
  Sample(void);
  ~Sample(void);
  int getFoo(void) const;
  void setFoo(int v);
private:
  int _foo;
};

// Sample.class.
int Sample::getFoo(void) const {
  return this->_foo;
}

void Sample::setFoo(int v) {
  this->_foo = v;
}
#+END_SRC
** comparisons
In C++, structures and classes are no longer compared by addresses;
which means that you can compare structs/classes by value. But, to do
that, you have to set up a few things.

#+NAME: comparisons
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample {
public:
  Sample(int v);
  ~Sample(void);

  int getFoo(void) const;
  int compare(Sample *other) const;

private:
  int _foo;
};

// Sample.class.cpp
#include "Sample.class.hpp"

int Sample::compare(Sample *other) const {
  if (this->_foo < other->getFoo())
    return (-1);
  else if (...)
    return (1);
  return (0);
}
#+END_SRC

So, basically, you have to implement that manually... That's not
really much better.
** non-member attributes and functions
Classes also have non-member attributes and functions (class attrs/fcts); these operate at the class-level, instead of at the instance-level.

The static keyword means something different in C++. It is used to
declare non-member attributes and functions.

#+NAME: non-member
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample {
public:
  // Const/Dest
  static int getNbInst(void);
private:
  static int _nbInst;
};

// Sample.class.cpp

Sample::Sample(void) {
  Sample::_nbInst += 1;
}

int Sample::getNbInst(void) {
  return (Sample::_nbInst);
}

int Sample::_nbInst = 0;
#+END_SRC

Here, it makes no sense to have a nbInst variable at the instance
level, because, obviously, you want to know how many instances have
been instantiated; so, class-level stuff.

Also, the this-> keyword is unavailable in non-member functions and
attributes; which makes sense, because you'Re not operating at the
instance level (therefore 'this->' doesn't exist'). But, you can use
the ~<CLASS_NAME>::<VARIABLE>~.

Kinda confusing, but the last line is the only way we have to
initialize a static (non-member attribute). In order, to increment it,
we do it when a constructor of this class is called, and decrement it
when the constructor is called.
** pointers to member attributes and functions
So... Pointers...

#+NAME: pointers-member
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample {
public:
  int foo;
  // Destr/Constr
  void bar(void) const;
};

// Sample.class.cpp

// main.c
int main(void) {
  Sample instance;
  Sample *instanceptr = &instance;
  int Sample::*p = NULL;
  void (Sample::*f)(void) const;

  p = &Sample::foo;
  instance.*p = 21;
  instanceptr->*p = 42;

  f = &Sample::bar;
  (instance.*f)();
  (instance->*f)();
}
#+END_SRC

Allright, so. The first pointer is straightforward: you declare a
Sample pointer, and initialize its value to the address of another
value.

The syntax for the two other pointers seems complex, but we're just
declaring pointers with some added logical-syntactic sugar. The
~Sample::~ syntax specifies that the pointer MUST be a member of the
class instance.

The ~instance.*p = 21~ syntax means, assign 21 to the value of the ~p~
variable of the instance ~instance~. If you're dealing with a pointer
to a structure, use the -> notation.

Declaring an array of function pointers:
#+NAME: array-of-fpointers
#+BEGIN_SRC C++
  void (Sample::*functions[4])(void) = {
    &Sample::fct1,
    &Sample::fct2,
    &Sample::fct2,
    &Sample::fct4
  };

  for (int i = 0; i < 4; i++) {
    (this->*functions[i])();
  }
#+END_SRC

Still a bit unclear on using them; especially, the use of ~this->~ and
how it maps to the functions. Is it getting the address of that
function for that instance? Gotta figure that out...

** new and delete
:PROPERTIES:
:SCHEDULED: <2022-11-14>

:END:
Even though malloc is allowed in C++, NEVER use it. Use new and delete
because these functions call, respectively, the object's constructor
and destructor. Here's how you can allocate memory in C++:

#+NAME: memory-allocation
#+BEGIN_SRC C++
class Student {
  private:
    ...
};

int main(void)
{
  Student *jim = new Student("login");
  Student *students = new Student[42];

  // do some stuff
  delete jim;
  delete [] students; // strange syntax, but that's how it works.
  return (0); // classes are destroyed
}
#+END_SRC

One thing to keep in mind, when allocating arrays of structures, it is
IMPOSSIBLE to initialize values at construction. Therefore, you must
find a way around that.

** references
Somewhat similar to pointers.

A reference is a const pointer that is always dereferenced and is
never NULL. The reference is not a copy or a pointer; it IS the
object. From the [[https://isocpp.org/wiki/faq/references#overview-refs][C++ FAQ]]:

#+begin_quote
Even though a reference is often implemented using an address in the
underlying assembly language, please do not think of a reference as a
funny looking pointer to an object. A reference is the object. It is
not a pointer to the object, nor a copy of the object. It is the
object.
#+end_quote


#+BEGIN_SRC C++
#include <iostream>

int main(void)
{
  int num = 42;

  int& numRef = num;
  std::cout << num << numRef << std::endl;
}
#+END_SRC

#+RESULTS:
: 4242

** filestreams
As we've seen, we can interact with streams like stdout, stdin, and
stderr. All simple enough. And, as in C, you can interact with
filestreams. To do so, we use the ~<fstream>~ header.

#+NAME: filestreams
#+BEGIN_SRC C++
#include <fstream>
#include <iostream>

int main(void) {
  std::ifstream ifs("numbers");
  unsigned int dst;
  unsigned int dst2;

  ifs >> dst >> dst2;
  std::cout << dst << " " << dst2 << std::endl;
  ifs.close();
}
#+END_SRC

The line ~std::ifstream ifs("numbers")~ associates an input file
stream (ifstream) with the (opened) file 'numbers'.

A simple way to read through files. You can redirect output to any
kind of stream.

#+NAME: reading-filestreams
#+BEGIN_SRC C++ :results output
#include <fstream>
#include <string>
#include <iostream>

int main(void) {
  std::ofstream ofs;
  std::ifstream ifs;

  ifs.open("/Users/tgarriss/Projects/42/cpp/01/ex04/somefile.txt");
  ofs.open("/Users/tgarriss/Projects/42/cpp/01/ex04/somefile.replace");
  if (ifs.is_open())
  {
    std::string line;
    while (std::getline(ifs, line))
      ofs << line << std::endl;
  }
  else
    std::cout << "FAILURE!" << std::endl;
  return (0);
}
#+END_SRC

#+RESULTS: reading-filestreams

There are also string streams apparently. Look that up. I've written
some basic info about it in code... But that's not enough. There's
likely an initialization method to interact with a string or
something...

#+NAME: string-streams
#+BEGIN_SRC C++
#include <string>
#include <iostream>
#include <sstream>

int main(void) {
  std::stringstream ss;

  ss << 100 << ' ' << 200;

  int foo,bar;
  ss >> foo >> bar;
  std::cout << foo << std::endl;
  std::cout << bar << std::endl;
}
#+END_SRC

#+RESULTS: string-streams
: 100
: 200
** strings
There's a bunch of neat functions for strings. Look at:
- .compare()
- .size()
- .append()
- .assign()
- .replace()
** switch statements
switch statements are the same in CPP and C. They're straightforward
to use. Simply remember that they fall through:

#+NAME: switch-statements
#+BEGIN_SRC C++
#include <iostream>

int main(void) {
  int i;

  i = 1;
  switch (i) {
    case 1:
      std::cout << "Case 1!" << std::endl;
    case 2:
      std::cout << "Case 2!" << std::endl;
      break;
    case 3:
      std::cout << "Case 3!" << std::endl;

  }
}
#+END_SRC
** adhoc polymorphism
adhoc polymorphism (aka function overloading) is a principle in C++
that allows us to use the same name for functions that take different
parameters. A simple example:

#+NAME: adhoc-polymorphism
#+BEGIN_SRC C++ :results output
#include <iostream>

// Sample.class.hpp
class Sample {
  public:
    Sample(void);
    ~Sample(void);

    void bar(char const c) const;
    void bar(int const n) const;
    void bar(float const z) const;
    void bar(Sample const &i) const;
};

// Sample.class.cpp
Sample::Sample(void) {};
Sample::~Sample(void) {};

void Sample::bar(char const c) const {
  std::cout << "char" << std::endl;
}

void Sample::bar(int const n) const {
  std::cout << "int" << std::endl;
}

void Sample::bar(float const z) const {
  std::cout << "float" << std::endl;
}

void Sample::bar(Sample const &i) const {
  std::cout << "sample" << std::endl;
}

// main.cpp
int main(void) {
  Sample s;
  Sample &s2 = s;

  s.bar('a');
  s.bar(42);
  s.bar(4.2f);
  s.bar(s2);
}
#+END_SRC

** operator overloads
Operator Overloading allows us to augment C++ operators; to add on
specific functionalities (like adding two classes together).

There are several ways to write operators in a mathematical
expression: prefix, infix, postfix (~+ 1 1~, ~1 + 1~, ~1 1 +~). The
prefix notation, also called functional syntax because of its
ressemblance to a function call (~+(1, 1)~), is the key to
understanding operator overloads.

Let's imagine that we're working with instances of classes. The same
idea might be expressed as: ~1.+(1)~. From the instance '1', call the
member function '+' with the argument '1'.

Operator Overloads are declared in their respective .hpp files. The
syntax goes like this:

#+NAME: declare-overloads
#+BEGIN_SRC C++ :noweb yes
class Integer {
  public:
    Integer(int const n);
    ~Integer(void);
    int getValue(void) const;
    Integer & operator=(Integer const & rhs);
    Integer operator+(Integer const & rhs) const;
  private:
    int _n;
};

std::ostream & operator<<(std::ostream & o, Integer const & rhs);
#+END_SRC

Some syntax explanations:
  1) The 'operator' keyword and its respective symbol (+-=...) is used
     to declare operator overload functions.
  2) 'rhs' stands for 'right hand side' ('lhs', 'left hand side') of
     the operation. As in, (lhs) 1 + 1 (rhs).
  3) The '+' operator overload function is const because it never
     modifies the instance; e.g. the 1s in '1 + 1' are never modified,
     they return something)
  4) the '=' operator overload function is !const because it modifies
     the instance's value; i.e., it assigns something new to it.
  5) the '=' operator overload function must return a reference to
     itself to accomodate assignation chaining (~a = b = c = d;~).
  6) the '+' operator overload function returns a copy of itself.

This is how they would be implemented:
#+NAME: define-overloads
#+BEGIN_SRC C++ :noweb yes
Integer::Integer(int const n) : _n(n) {}
Integer::~Integer() {}

int Integer::getValue(void) const {
  return (this->_n);
}

Integer & Integer::operator=(Integer const & rhs) {
  this->_n = rhs.getValue();
  return (*this);
}

Integer Integer::operator+(Integer const & rhs) const {
  return (Integer(this->_n + rhs.getValue()));
}

std::ostream & operator<<(std::ostream & o, Integer const & rhs) {
  o << rhs.getValue();
  return (o);
}
#+END_SRC

The stream redirection overload cannot use member functions, since it
cannot modify the std::ostream class (how come?). Therefore, note that
the declaration of the '<<' overload is outside the class definition,
and that there is no ~Integer::~ in the definition.

#+NAME: main-overload
#+BEGIN_SRC C++ :noweb yes :results output
#include <iostream>

<<declare-overloads>>
<<define-overloads>>

int main(void) {
  Integer x(30);
  Integer y(10);
  Integer z(0);

  std::cout << "value of x: " << x << std::endl;
  std::cout << "value of y: " << y << std::endl;
  y = Integer(12);
  std::cout << "newvalue of y: " << y << std::endl;
  std::cout << "value of z: " << z << std::endl;
  z = x + y;
  std::cout << "newvalue of z: " << z << std::endl;
}
#+END_SRC

BEWARE! There are a few rules to maintain conceptual clarity when
writing operator overloads:
  1) it should feel natural
  2) didn't understand the video... well... too bad.
  3) DON'T USE THEM! There are better ways of implementing the same behavior.

You can also overload increment/decrement operators. The syntax is
weird and arbitrary: for postfix increment/decrement, you must pass an
int to the overloading function. e.g.:
#+NAME: incr-decr-overloads
#+BEGIN_SRC C++
// prefix incr
Sample & Sample::operator++(void) {
  this->_value++;
  return (*this);
}

// postfix decr
Sample Sample::operator--(int) {
  Sample tmp;

  tmp = *this;
  --*this;
  return (tmp);
}
#+END_SRC

** canonical form
The canonical form is a norm for writing classes; it is merely for
clarity and consistency. A canonical form contains, at least:
  1) a default constructor
  2) a copy constructor (a constructor that takes another instance to
     become a copy of it).
  3) a '=' operator overload.
  4) a default destructor.
  5) a virtual destructor (to be define later)

As optional, but useful features, think of implementing:
  1) the stream redirection '<<' operator overload
  2) something that serializes your class into a string (like for a
     json object)

#+NAME: canonical-form-define
#+BEGIN_SRC C++ :noweb yes
#include <iostream>
class Sample {
  public:
    Sample(void);    // default constructor
    Sample(int const n);
    Sample(Sample const & src);    // copy constructor
    ~Sample(void);    // default destructor

    Sample & operator=(Sample const & rhs);    // '=' overload
    int getValue(void) const;
  private:
    int _value;
};

std::ostream & operator<<(std::ostream & o, Sample const & i);    // optional stream redirection
#+END_SRC

#+NAME: canonical-form-declare
#+BEGIN_SRC C++ :noweb yes
Sample::Sample(void) : _value(0) {std::cout << "default constr." << std::endl;}
Sample::Sample(int const n) : _value(n) {std::cout << "parametric constr." << std::endl;}
Sample::Sample(Sample const & src) {
  std::cout << "copy constr" << std::endl;
  *this = src;
  return ;
}

Sample::~Sample(void) {std::cout << "default destr." << std::endl;}

int Sample::getValue(void) const {return (this->_value);}

Sample & Sample::operator=(Sample const & rhs) {
  std::cout << "= operator" << std::endl;
  if (this != &rhs)
    this->_value = rhs.getValue();
  return (*this);
}
std::ostream & operator<<(std::ostream & o, Sample const & i) {
  o << "stream redir. value is: " << i.getValue() << std::endl;
  return (o);
}
#+END_SRC

#+RESULTS: canonical-form-declare

#+NAME: canonical-main
#+BEGIN_SRC C++ :noweb yes :results output
<<canonical-form-define>>
<<canonical-form-declare>>

int main(void) {
  Sample instance1;
  Sample instance2(42);
  Sample instance3(instance1);

  std::cout << instance1 << std::endl;
  std::cout << instance2 << std::endl;
  std::cout << instance3 << std::endl;

  instance3 = instance2;
  std::cout << instance3 << std::endl;
  return (0);
}
#+END_SRC
