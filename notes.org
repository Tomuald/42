:PROPERTIES:
#+title: Notes
:END:

A collection of notes concerning 42 Projects.

* C++
** files & extensions
Files in cpp use the .cpp/.hpp extensions. It makes it easier for
compilators usually. When defining or declaring a class inside a file,
use: <NAME>.class.cpp/.hpp.
** classes
A basic class is declared in an .hpp file, like this:

#+NAME: basic-class-declare
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
class Sample
{
public:
  Sample(void);
  ~Sample(void);
};
#+END_SRC

Sample() and ~Sample() are the class's constructor and destructor.
They both have no return type, since they are procedures and not
really functions. The constructor is called as soon as you instanciate
a class. If defined locally, the class's destructor is called when the
function reaches it return() call.

#+NAME: basic-class-define
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
#include "Sample.class.hpp"

Sample::Sample(void)
{
  return ;
}

Sample::~Sample(void)
{
  return ;
}
#+END_SRC

To initialize an instance of class:
#+NAME: basic-class-instance
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
#include "Sample.class.hpp"

int main(int argc, char **argv)
{
  Sample    instance;

  return (0);
}
#+END_SRC

Instances of a class are simple: they're like any other old variable
or struct; they're objects; think of the mold/cake allegory.
** member attributes and functions
These are variables and functions defined in the body of a class.

#+NAME: member-attr-func
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
// Sample.class.hpp
class Sample(void)
{
public:
  Sample();
  ~Sample();

  int i;
  int is_active(void);
};

// Sample.class.cpp
#include "Sample.class.hpp"

// Constructor()
// ~Destructor()

// See section of the this-> keyword.
int Sample::is_active(void)     {
  if (this->i)
    return (1);
  return (0);
}

// main.c
#include "Sample.class.hpp"

int main(void) {
  Sample instance;

  instance.i = 1;
  instance.is_active();
  return (0);
}
#+END_SRC
** this-> keyword
The this-> keyword is a pointer to the current instance. It allows you
to manipulate the data within:

#+NAME: basic-this
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
class Sample {
public:
  Sample(void);
  ~Sample(void);
  int i;
  int c;
  int set_c(void);
};
#+END_SRC

#+NAME: basic-this-2
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
#include "Sample.class.hpp"

Sample::Sample(void)
{
  this->i = 42;
  set_c();
  return ;
}

int Sample::set_c(void)
{
  this->c = 24;
  return (0);
}
#+END_SRC
** initialization lists
Initialization lists allow you to succintly setup variables during a
class's construction. Given the class below:

#+NAME: init-lists
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
// Sample.class.hpp
class Sample
{
public:
  char a1;
  int a2;
  float a3;

  Sample(char p1, int p2, float p3);
  ~Sample(void);
};

// Sample.class.cpp
#include "Sample.class.hpp"

Sample::Sample(char p1, int p2, float p3) : a1(p1), a2(p2), a3(p3)
{
  return ;
}
#+END_SRC

The format ~: a1(p1), a2(p2), a3(p3)~ sets the variable aX to the
value pX implicitly.

Initialization lists can be much more complex than this. We'll dive
into more detail later on.
** const keyword
const keywords are great. They allow to set values that will NEVER be
allowed to be modified or assigned to. It might be the difference
between a working program and a program that fucks up royally. Make
sure to use these keywords freely when writing C++ code; it will make
it more robust, and harder to break.

Be mindful of where the const keyword goes though!
  1) ~const int i~ declares a constant integer
  2) ~const int * i2 || int const * i2~ declares a variable pointer to a const integer
  3) ~int * const i3~ declares a constant pointer to a variable integer
  4) ~int const * const i2~ declares a constant pointer to a constant integer
  5) ~class Sample{ void function() const}~ declares that the member
     function 'function' CANNOT modify the values of the class.

Since const variables can NEVER be assigned a value, if we're working
in a class, we need to bypass that by initializing them with the same
concept of [[initialization lists][initialization lists]].

#+NAME: const-init
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp
class Sample
{
public:
  float const pi;
  int qd;

  Sample(float const f);
  ~Sample(void);

  void bar(void) const;
};

// Sample.class.cpp
Sample::Sample(float const f) : pi(f)
{
  return ;
}

void Sample::bar(void) const
{
  return ;
}
#+END_SRC

The difference is subtle, but here, we are INITIALIZING the variable,
not assigning to them.

We snuck in a const somewhere in the .hpp that might seem unusual:
~void bar(void) const~. This const applies to the function itself, and
means that NOWHERE in it's body will there be any type of assignation
to the members attributes of the class (no ~this->a = 42~, etc).
** static keyword
The static keyword in C++ can be found in a few places:
  1) as a ~static <type> var~ outside of a class. i.e., that it gets
     allocated memory for the lifetime of the program. Just like in C,
     this variable persists through function calls.
  2) as a ~static <type> var~ inside of a class. i.e., they are init'd
     once, and are allocated memory in static storage (!contiguous to
     the class); each instance share the same memory location, and
     value.
  3) as static member variables... Come back to this later.
** visibility (public vs private vs protected)
public vs private keywords restrain which attributes/functions are
accessible from within and outside the class. Private attrs/fcts are
INnaccesible from outside the class; whereas public ones can be
accessed from anywhere. Basically, think of the public attrs as the
ones that your user can access, and private ones as the ones your code
can access.

There is a convention to use the underscore (_var || var _) to
highlight private attributes. Its purpose is to make the code easier
to read, and understand at a glance, which is private, which is
public.

The protected keyword allows an inheriting class to access the
designated variables and functions.

#+NAME: visibility
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
class Sample {
  private:
    std::string name; // only accessible from a Sample object
  protected:
    std::string age; // accessible from a Sample object or a derived object
  public:
    void samplify(void) const; // accessible from anywhere
};
#+END_SRC
** accessors
accessors are functions that allow to retrieve the values of your
private attributes (get() and set() functions).

Naming conventions are get<Attrb>(), set<Attrb>().

#+NAME: accessors
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample
{
public:
  Sample(void);
  ~Sample(void);
  int getFoo(void) const;
  void setFoo(int v);
private:
  int _foo;
};

// Sample.class.
int Sample::getFoo(void) const {
  return this->_foo;
}

void Sample::setFoo(int v) {
  this->_foo = v;
}
#+END_SRC
** comparisons
In C++, structures and classes are no longer compared by addresses;
which means that you can compare structs/classes by value. But, to do
that, you have to set up a few things.

#+NAME: comparisons
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample {
public:
  Sample(int v);
  ~Sample(void);

  int getFoo(void) const;
  int compare(Sample *other) const;

private:
  int _foo;
};

// Sample.class.cpp
#include "Sample.class.hpp"

int Sample::compare(Sample *other) const {
  if (this->_foo < other->getFoo())
    return (-1);
  else if (...)
    return (1);
  return (0);
}
#+END_SRC

So, basically, you have to implement that manually... That's not
really much better.
** non-member attributes and functions
Classes also have non-member attributes and functions (class attrs/fcts); these operate at the class-level, instead of at the instance-level.

The static keyword means something different in C++. It is used to
declare non-member attributes and functions.

#+NAME: non-member
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample {
public:
  // Const/Dest
  static int getNbInst(void);
private:
  static int _nbInst;
};

// Sample.class.cpp

Sample::Sample(void) {
  Sample::_nbInst += 1;
}

int Sample::getNbInst(void) {
  return (Sample::_nbInst);
}

int Sample::_nbInst = 0;
#+END_SRC

Here, it makes no sense to have a nbInst variable at the instance
level, because, obviously, you want to know how many instances have
been instantiated; so, class-level stuff.

Also, the this-> keyword is unavailable in non-member functions and
attributes; which makes sense, because you'Re not operating at the
instance level (therefore 'this->' doesn't exist'). But, you can use
the ~<CLASS_NAME>::<VARIABLE>~.

Kinda confusing, but the last line is the only way we have to
initialize a static (non-member attribute). In order, to increment it,
we do it when a constructor of this class is called, and decrement it
when the constructor is called.
** pointers to member attributes and functions
So... Pointers...

#+NAME: pointers-member
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample {
public:
  int foo;
  // Destr/Constr
  void bar(void) const;
};

// Sample.class.cpp

// main.c
int main(void) {
  Sample instance;
  Sample *instanceptr = &instance;
  int Sample::*p = NULL;
  void (Sample::*f)(void) const;

  p = &Sample::foo;
  instance.*p = 21;
  instanceptr->*p = 42;

  f = &Sample::bar;
  (instance.*f)();
  (instance->*f)();
}
#+END_SRC

Allright, so. The first pointer is straightforward: you declare a
Sample pointer, and initialize its value to the address of another
value.

The syntax for the two other pointers seems complex, but we're just
declaring pointers with some added logical-syntactic sugar. The
~Sample::~ syntax specifies that the pointer MUST be a member of the
class instance.

The ~instance.*p = 21~ syntax means, assign 21 to the value of the ~p~
variable of the instance ~instance~. If you're dealing with a pointer
to a structure, use the -> notation.

Declaring an array of function pointers:
#+NAME: array-of-fpointers
#+BEGIN_SRC C++
  void (Sample::*functions[4])(void) = {
    &Sample::fct1,
    &Sample::fct2,
    &Sample::fct2,
    &Sample::fct4
  };

  for (int i = 0; i < 4; i++) {
    (this->*functions[i])();
  }
#+END_SRC

Still a bit unclear on using them; especially, the use of ~this->~ and
how it maps to the functions. Is it getting the address of that
function for that instance? Gotta figure that out...

** new and delete
:PROPERTIES:
:SCHEDULED: <2022-11-14>

:END:
Even though malloc is allowed in C++, NEVER use it. Use new and delete
because these functions call, respectively, the object's constructor
and destructor. Here's how you can allocate memory in C++:

#+NAME: memory-allocation
#+BEGIN_SRC C++
class Student {
  private:
    ...
};

int main(void)
{
  Student *jim = new Student("login");
  Student *students = new Student[42];

  // do some stuff
  delete jim;
  delete [] students; // strange syntax, but that's how it works.
  return (0); // classes are destroyed
}
#+END_SRC

One thing to keep in mind, when allocating arrays of structures, it is
IMPOSSIBLE to initialize values at construction. Therefore, you must
find a way around that.

** references
Somewhat similar to pointers, in the sense that it is
pass-by-reference (instead of pass-by-value). Generally, in C++, you
use references when you can, and pointers when you need to. A few
guidelines:
  1) if you want to change the object passed, call by reference or use a pointer; e.g., ~void f(int & i) || void f(int * i)~
  2) if you don't want to change the object and it is big, call by const reference; e.g., ~void f(const & i)~
  3) otherwise, call by value; e.g. ~void f(int i)~

A reference is a const pointer that is always dereferenced and is
never NULL. The reference is not a copy or a pointer; it IS the
object. From the [[https://isocpp.org/wiki/faq/references#overview-refs][C++ FAQ]]:

#+begin_quote
Even though a reference is often implemented using an address in the
underlying assembly language, please do not think of a reference as a
funny looking pointer to an object. A reference is the object. It is
not a pointer to the object, nor a copy of the object. It is the
object.
#+end_quote


#+BEGIN_SRC C++
#include <iostream>

int main(void)
{
  int num = 42;

  int& numRef = num;
  std::cout << num << numRef << std::endl;
}
#+END_SRC

#+RESULTS:
: 4242

** filestreams
As we've seen, we can interact with streams like stdout, stdin, and
stderr. All simple enough. And, as in C, you can interact with
filestreams. To do so, we use the ~<fstream>~ header.

#+NAME: filestreams
#+BEGIN_SRC C++
#include <fstream>
#include <iostream>

int main(void) {
  std::ifstream ifs("numbers");
  unsigned int dst;
  unsigned int dst2;

  ifs >> dst >> dst2;
  std::cout << dst << " " << dst2 << std::endl;
  ifs.close();
}
#+END_SRC

The line ~std::ifstream ifs("numbers")~ associates an input file
stream (ifstream) with the (opened) file 'numbers'.

A simple way to read through files. You can redirect output to any
kind of stream.

#+NAME: reading-filestreams
#+BEGIN_SRC C++ :results output
#include <fstream>
#include <string>
#include <iostream>

int main(void) {
  std::ofstream ofs;
  std::ifstream ifs;

  ifs.open("/Users/tgarriss/Projects/42/cpp/01/ex04/somefile.txt");
  ofs.open("/Users/tgarriss/Projects/42/cpp/01/ex04/somefile.replace");
  if (ifs.is_open())
  {
    std::string line;
    while (std::getline(ifs, line))
      ofs << line << std::endl;
  }
  else
    std::cout << "FAILURE!" << std::endl;
  return (0);
}
#+END_SRC

#+RESULTS: reading-filestreams

There are also string streams apparently. Look that up. I've written
some basic info about it in code... But that's not enough. There's
likely an initialization method to interact with a string or
something...

#+NAME: string-streams
#+BEGIN_SRC C++
#include <string>
#include <iostream>
#include <sstream>

int main(void) {
  std::stringstream ss;

  ss << 100 << ' ' << 200;

  int foo,bar;
  ss >> foo >> bar;
  std::cout << foo << std::endl;
  std::cout << bar << std::endl;
}
#+END_SRC

#+RESULTS: string-streams
: 100
: 200
** strings
There's a bunch of neat functions for strings. Look at:
- .compare()
- .size()
- .append()
- .assign()
- .replace()
** switch statements
switch statements are the same in CPP and C. They're straightforward
to use. Simply remember that they fall through:

#+NAME: switch-statements
#+BEGIN_SRC C++
#include <iostream>

int main(void) {
  int i;

  i = 1;
  switch (i) {
    case 1:
      std::cout << "Case 1!" << std::endl;
    case 2:
      std::cout << "Case 2!" << std::endl;
      break;
    case 3:
      std::cout << "Case 3!" << std::endl;

  }
}
#+END_SRC

#+RESULTS: switch-statements
| Case | 1! |
| Case | 2! |

** adhoc polymorphism
adhoc polymorphism (aka function overloading) is a principle in C++
that allows us to use the same name for functions that take different
parameters. A simple example:

#+NAME: adhoc-polymorphism
#+BEGIN_SRC C++ :results output
#include <iostream>

// Sample.class.hpp
class Sample {
  public:
    Sample(void);
    ~Sample(void);

    void bar(char const c) const;
    void bar(int const n) const;
    void bar(float const z) const;
    void bar(Sample const &i) const;
};

// Sample.class.cpp
Sample::Sample(void) {};
Sample::~Sample(void) {};

void Sample::bar(char const c) const {
  std::cout << "char" << std::endl;
}

void Sample::bar(int const n) const {
  std::cout << "int" << std::endl;
}

void Sample::bar(float const z) const {
  std::cout << "float" << std::endl;
}

void Sample::bar(Sample const &i) const {
  std::cout << "sample" << std::endl;
}

// main.cpp
int main(void) {
  Sample s;
  Sample &s2 = s;

  s.bar('a');
  s.bar(42);
  s.bar(4.2f);
  s.bar(s2);
}
#+END_SRC

** operator overloads
Operator Overloading allows us to augment C++ operators; to add on
specific functionalities (like adding two classes together).

There are several ways to write operators in a mathematical
expression: prefix, infix, postfix (~+ 1 1~, ~1 + 1~, ~1 1 +~). The
prefix notation, also called functional syntax because of its
ressemblance to a function call (~+(1, 1)~), is the key to
understanding operator overloads.

Let's imagine that we're working with instances of classes. The same
idea might be expressed as: ~1.+(1)~. From the instance '1', call the
member function '+' with the argument '1'.

Operator Overloads are declared in their respective .hpp files. The
syntax goes like this:

#+NAME: declare-overloads
#+BEGIN_SRC C++ :noweb yes
class Integer {
  public:
    Integer(int const n);
    ~Integer(void);
    int getValue(void) const;
    Integer & operator=(Integer const & rhs);
    Integer operator+(Integer const & rhs) const;
  private:
    int _n;
};

std::ostream & operator<<(std::ostream & o, Integer const & rhs);
#+END_SRC

Some syntax explanations:
  1) The 'operator' keyword and its respective symbol (+-=...) is used
     to declare operator overload functions.
  2) 'rhs' stands for 'right hand side' ('lhs', 'left hand side') of
     the operation. As in, (lhs) 1 + 1 (rhs).
  3) The '+' operator overload function is const because it never
     modifies the instance; e.g. the 1s in '1 + 1' are never modified,
     they return something)
  4) the '=' operator overload function is !const because it modifies
     the instance's value; i.e., it assigns something new to it.
  5) the '=' operator overload function must return a reference to
     itself to accomodate assignation chaining (~a = b = c = d;~).
  6) the '+' operator overload function returns a copy of itself.

This is how they would be implemented:
#+NAME: define-overloads
#+BEGIN_SRC C++ :noweb yes
Integer::Integer(int const n) : _n(n) {}
Integer::~Integer() {}

int Integer::getValue(void) const {
  return (this->_n);
}

Integer & Integer::operator=(Integer const & rhs) {
  this->_n = rhs.getValue();
  return (*this);
}

Integer Integer::operator+(Integer const & rhs) const {
  return (Integer(this->_n + rhs.getValue()));
}

std::ostream & operator<<(std::ostream & o, Integer const & rhs) {
  o << rhs.getValue();
  return (o);
}
#+END_SRC

The stream redirection overload cannot use member functions, since it
cannot modify the std::ostream class (how come?). Therefore, note that
the declaration of the '<<' overload is outside the class definition,
and that there is no ~Integer::~ in the definition.

#+NAME: main-overload
#+BEGIN_SRC C++ :noweb yes :results output
#include <iostream>

<<declare-overloads>>
<<define-overloads>>

int main(void) {
  Integer x(30);
  Integer y(10);
  Integer z(0);

  std::cout << "value of x: " << x << std::endl;
  std::cout << "value of y: " << y << std::endl;
  y = Integer(12);
  std::cout << "newvalue of y: " << y << std::endl;
  std::cout << "value of z: " << z << std::endl;
  z = x + y;
  std::cout << "newvalue of z: " << z << std::endl;
}
#+END_SRC

BEWARE! There are a few rules to maintain conceptual clarity when
writing operator overloads:
  1) it should feel natural
  2) didn't understand the video... well... too bad.
  3) DON'T USE THEM! There are better ways of implementing the same behavior.

You can also overload increment/decrement operators. The syntax is
weird and arbitrary: for postfix increment/decrement, you must pass an
int to the overloading function. e.g.:
#+NAME: incr-decr-overloads
#+BEGIN_SRC C++
// prefix incr
Sample & Sample::operator++(void) {
  this->_value++;
  return (*this);
}

// postfix decr
Sample Sample::operator--(int) {
  Sample tmp;

  tmp = *this;
  --*this;
  return (tmp);
}
#+END_SRC

** canonical form
The canonical form is a norm for writing classes; it is merely for
clarity and consistency. A canonical form contains, at least:
  1) a default constructor
  2) a copy constructor (a constructor that takes another instance to
     become a copy of it).
  3) a '=' operator overload.
  4) a default destructor.
  5) a virtual destructor (to be define later)

As optional, but useful features, think of implementing:
  1) the stream redirection '<<' operator overload
  2) something that serializes your class into a string (like for a
     json object)

#+NAME: canonical-form-declare
#+BEGIN_SRC C++ :noweb yes
class Sample {
  public:
    Sample(void);    // default constructor
    Sample(Sample const & src);    // copy constructor
    ~Sample(void);    // default destructor

    Sample & operator=(Sample const & rhs);    // '=' overload
  private:
    int _value;
};

std::ostream & operator<<(std::ostream & o, Sample const & i);    // optional stream redirection
#+END_SRC

#+NAME: canonical-form-define
#+BEGIN_SRC C++ :noweb yes
Sample::Sample(void) : _value(0) {std::cout << "default constr." << std::endl;}
Sample::Sample(Sample const & src) {
  std::cout << "copy constr" << std::endl;
  *this = src;
  return ;
}

Sample::~Sample(void) {std::cout << "default destr." << std::endl;}

Sample & Sample::operator=(Sample const & rhs) {
  std::cout << "= operator" << std::endl;
  if (this != &rhs)
    this->_value = rhs.getValue();
  return (*this);
}
std::ostream & operator<<(std::ostream & o, Sample const & i) {
  o << "stream redir. value is: " << i.getValue() << std::endl;
  return (o);
}
#+END_SRC

#+RESULTS: canonical-form-declare

#+NAME: canonical-main
#+BEGIN_SRC C++ :noweb yes :results output
<<canonical-form-declare>>
<<canonical-form-define>>

int main(void) {
  Sample instance1;
  Sample instance2(42);
  Sample instance3(instance1);

  std::cout << instance1 << std::endl;
  std::cout << instance2 << std::endl;
  std::cout << instance3 << std::endl;

  instance3 = instance2;
  std::cout << instance3 << std::endl;
  return (0);
}
#+END_SRC
** inheritance
Basically lets you abstract behaviours of a class, and use them in
other classes. This lets you cut down on the amount of redundancy, at
the cost of complexity. Try to limit inheritance to 2 levels.

#+NAME: inheritance
#+BEGIN_SRC C++ :results output
#include <string>

class Animal {
  private:
    int _numOfLegs;
  public:
    Animal();
    Animal(Animal const &);
    Animal & operator=(Animal const &);
    ~Animal(void);

    void run(int distance);
};

class Cat : public Animal {
  public:
    Cat(void);
    Cat(Cat const &);
    Cat & operator=(Cat const &);
    ~Cat();

    void scornSomeone(std::string const & msg);
};

int main(void) {
  Cat cat;

  cat.scornSomeone("Laaaaaaame!");
}
#+END_SRC

You can also override functions from the parent class by defining the
same function in the child.

When declaring a class that inherits from another, you must specify
the type of encapsulation. All the member of the base class are part
of the derived class. However, the derived class can only access
members that are public or protected. In the example above, it is
~public~, but you'll find two others:
1) *public inheritance* makes public members of the base class public in
   the derived class, and the protected members of the base class
   remain protected in the derived class.
2) *protected inheritance* makes the public and protected members of the
   base class protected in the derived class.
3) *private inheritance* makes the public and protected members of the
   base class private in the derived class.

When a derived class is called, its base class is constructed first,
then the derived instance is constructed. When a derived class is
destroyed, the derived class is destroyed first, then its parent
class.
** subtype polymorphism
Subtype polymorphism is basically the same thing as inheritance; it is
often called this, and class subtyping. It implies another logical
concept though, that of relationships between classes.

Run the ~main()~ below, you'll find that you can assign a Warrior
class to a Character object since a Warrior IS-A Character. It does
not work the other way around (a Character IS-NOT-ALWAYS a Warrior).
But, initializing it like that tells the compiler to use the functions
associated with the Character class. Obviously, this only works when
classes are related; the Cat class has no relationship with the
Warrior, nor the Character class, and therefore will throw an error at
compilation.

#+NAME: polymorphism-virtual
#+BEGIN_SRC C++ :results output
#include <string>
#include <iostream>

class Character {
  public:
    void sayHello(std::string const & target);
    //virtual void sayHello(std::string const & target);
};

class Warrior : public Character {
  public:
    void sayHello(std::string const & target);
    //virtual void sayHello(std::string const & target);
};

class Cat {
  // ...
};

void Character::sayHello(std::string const & target) {
  std::cout << "Good day, " << target << " !" << std::endl;
}

void Warrior::sayHello(std::string const & target) {
  std::cout << "Go screw yourself, " << target << std::endl;
}

int main(void) {
  Character *a = new Character();
  Character *b = new Warrior();
  Warrior *c = new Warrior();
  Warrior *d = new Warrior();
  //Character *e = new Cat();

  a->sayHello("World");
  b->sayHello("Buttface");
  c->sayHello("Wormguts");
  d->sayHello("Water Buffalo");
  delete a, b, c, d;
}
#+END_SRC

#+RESULTS: polymorphism-virtual
: Good day, World !
: Good day, Buttface !
: Go screw yourself, Wormguts
: Go screw yourself, Water Buffalo

There is a way to get around that though, and it is to use the
~virtual~ keyword on a member function. Change the comments in the
code above to see how this works.

N.B.: 'methods' are virtual member functions.
** abstract classes and interfaces
Abstract classes are classes that cannot be instanciated directly. As
a norm, abstract class names are prefixed with an '*A*', as in ~class
ACharacter~.

Often you'll find 'pure methods' in abstract classes. These are
denoted by ending the function definition with ~public:
aFunction(void) = 0;~. This means that every subclass MUST define this
function, but it is NOT defined in the abstract class.

An interface is an abstract class that contains ONLY pure methods, and
has no attributes. Their names are prefixed with '*I*'. They are used
to conceptualize a class, that can be instantiated with a subclass. It
kinda gives a blueprint to build more complex classes with.
