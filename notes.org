:PROPERTIES:
#+title: Notes
:END:

A collection of notes concerning 42 Projects.

* C++
** files & extensions
Files in cpp use the .cpp/.hpp extensions. It makes it easier for
compilators usually. When defining or declaring a class inside a file,
use: <NAME>.class.cpp/.hpp.
** classes
A basic class is declared in an .hpp file, like this:

#+NAME: basic-class-declare
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
class Sample
{
public:
  Sample(void);
  ~Sample(void);
};
#+END_SRC

Sample() and ~Sample() are the class's constructor and destructor.
They both have no return type, since they are procedures and not
really functions. The constructor is called as soon as you instanciate
a class. If defined locally, the class's destructor is called when the
function reaches it return() call.

#+NAME: basic-class-define
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
#include "Sample.class.hpp"

Sample::Sample(void)
{
  return ;
}

Sample::~Sample(void)
{
  return ;
}
#+END_SRC

To initialize an instance of class:
#+NAME: basic-class-instance
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
#include "Sample.class.hpp"

int main(int argc, char **argv)
{
  Sample    instance;

  return (0);
}
#+END_SRC

Instances of a class are simple: they're like any other old variable
or struct; they're objects; think of the mold/cake allegory.
** member attributes and functions
These are variables and functions defined in the body of a class.

#+NAME: member-attr-func
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
// Sample.class.hpp
class Sample(void)
{
public:
  Sample();
  ~Sample();

  int i;
  int is_active(void);
};

// Sample.class.cpp
#include "Sample.class.hpp"

// Constructor()
// ~Destructor()

// See section of the this-> keyword.
int Sample::is_active(void)     {
  if (this->i)
    return (1);
  return (0);
}

// main.c
#include "Sample.class.hpp"

int main(void) {
  Sample instance;

  instance.i = 1;
  instance.is_active();
  return (0);
}
#+END_SRC
** this-> keyword
The this-> keyword is a pointer to the current instance. It allows you
to manipulate the data within:

#+NAME: basic-this
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
class Sample {
public:
  Sample(void);
  ~Sample(void);
  int i;
  int c;
  int set_c(void);
};
#+END_SRC

#+NAME: basic-this-2
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
#include "Sample.class.hpp"

Sample::Sample(void)
{
  this->i = 42;
  set_c();
  return ;
}

int Sample::set_c(void)
{
  this->c = 24;
  return (0);
}
#+END_SRC
** initialization lists
Initialization lists allow you to succintly setup variables during a
class's construction. Given the class below:

#+NAME: init-lists
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C++
// Sample.class.hpp
class Sample
{
public:
  char a1;
  int a2;
  float a3;

  Sample(char p1, int p2, float p3);
  ~Sample(void);
};

// Sample.class.cpp
#include "Sample.class.hpp"

Sample::Sample(char p1, int p2, float p3) : a1(p1), a2(p2), a3(p3)
{
  return ;
}
#+END_SRC

The format ~: a1(p1), a2(p2), a3(p3)~ sets the variable aX to the
value pX implicitly.

Initialization lists can be much more complex than this. We'll dive
into more detail later on.
** const keyword
const keywords are great. They allow to set values that will NEVER be
allowed to be modified or assigned to. It might be the difference
between a working program and a program that fucks up royally. Make
sure to use these keywords freely when writing C++ code; it will make
it more robust, and harder to break.

Be mindful of where the const keyword goes though!
  1) ~const int i~ declares a constant integer
  2) ~const int * i2 || int const * i2~ declares a variable pointer to a const integer
  3) ~int * const i3~ declares a constant pointer to a variable integer
  4) ~int const * const i2~ declares a constant pointer to a constant integer
  5) ~class Sample{ void function() const}~ declares that the member
     function 'function' CANNOT modify the values of the class.

Since const variables can NEVER be assigned a value, if we're working
in a class, we need to bypass that by initializing them with the same
concept of [[initialization lists][initialization lists]].

#+NAME: const-init
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp
class Sample
{
public:
  float const pi;
  int qd;

  Sample(float const f);
  ~Sample(void);

  void bar(void) const;
};

// Sample.class.cpp
Sample::Sample(float const f) : pi(f)
{
  return ;
}

void Sample::bar(void) const
{
  return ;
}
#+END_SRC

The difference is subtle, but here, we are INITIALIZING the variable,
not assigning to them.

We snuck in a const somewhere in the .hpp that might seem unusual:
~void bar(void) const~. This const applies to the function itself, and
means that NOWHERE in it's body will there be any type of assignation
to the members attributes of the class (no ~this->a = 42~, etc).
** static keyword
The static keyword in C++ can be found in a few places:
  1) as a ~static <type> var~ outside of a class. i.e., that it gets
     allocated memory for the lifetime of the program. Just like in C,
     this variable persists through function calls.
  2) as a ~static <type> var~ inside of a class. i.e., they are init'd
     once, and are allocated memory in static storage (!contiguous to
     the class); each instance share the same memory location, and
     value.
  3) as static member variables... Come back to this later.
** visibility (public vs private vs protected)
public vs private keywords restrain which attributes/functions are
accessible from within and outside the class. Private attrs/fcts are
INnaccesible from outside the class; whereas public ones can be
accessed from anywhere. Basically, think of the public attrs as the
ones that your user can access, and private ones as the ones your code
can access.

There is a convention to use the underscore (_var || var _) to
highlight private attributes. Its purpose is to make the code easier
to read, and understand at a glance, which is private, which is
public.

The protected keyword allows an inheriting class to access the
designated variables and functions.

#+NAME: visibility
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
class Sample {
  private:
    std::string name; // only accessible from a Sample object
  protected:
    std::string age; // accessible from a Sample object or a derived object
  public:
    void samplify(void) const; // accessible from anywhere
};
#+END_SRC
** accessors
accessors are functions that allow to retrieve the values of your
private attributes (get() and set() functions).

Naming conventions are get<Attrb>(), set<Attrb>().

#+NAME: accessors
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample
{
public:
  Sample(void);
  ~Sample(void);
  int getFoo(void) const;
  void setFoo(int v);
private:
  int _foo;
};

// Sample.class.
int Sample::getFoo(void) const {
  return this->_foo;
}

void Sample::setFoo(int v) {
  this->_foo = v;
}
#+END_SRC
** comparisons
In C++, structures and classes are no longer compared by addresses;
which means that you can compare structs/classes by value. But, to do
that, you have to set up a few things.

#+NAME: comparisons
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample {
public:
  Sample(int v);
  ~Sample(void);

  int getFoo(void) const;
  int compare(Sample *other) const;

private:
  int _foo;
};

// Sample.class.cpp
#include "Sample.class.hpp"

int Sample::compare(Sample *other) const {
  if (this->_foo < other->getFoo())
    return (-1);
  else if (...)
    return (1);
  return (0);
}
#+END_SRC

So, basically, you have to implement that manually... That's not
really much better.
** non-member attributes and functions
Classes also have non-member attributes and functions (class attrs/fcts); these operate at the class-level, instead of at the instance-level.

The static keyword means something different in C++. It is used to
declare non-member attributes and functions.

#+NAME: non-member
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample {
public:
  // Const/Dest
  static int getNbInst(void);
private:
  static int _nbInst;
};

// Sample.class.cpp

Sample::Sample(void) {
  Sample::_nbInst += 1;
}

int Sample::getNbInst(void) {
  return (Sample::_nbInst);
}

int Sample::_nbInst = 0;
#+END_SRC

Here, it makes no sense to have a nbInst variable at the instance
level, because, obviously, you want to know how many instances have
been instantiated; so, class-level stuff.

Also, the this-> keyword is unavailable in non-member functions and
attributes; which makes sense, because you'Re not operating at the
instance level (therefore 'this->' doesn't exist'). But, you can use
the ~<CLASS_NAME>::<VARIABLE>~.

Kinda confusing, but the last line is the only way we have to
initialize a static (non-member attribute). In order, to increment it,
we do it when a constructor of this class is called, and decrement it
when the constructor is called.
** pointers to member attributes and functions
So... Pointers...

#+NAME: pointers-member
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C++
// Sample.class.hpp

class Sample {
public:
  int foo;
  // Destr/Constr
  void bar(void) const;
};

// Sample.class.cpp

// main.c
int main(void) {
  Sample instance;
  Sample *instanceptr = &instance;
  int Sample::*p = NULL;
  void (Sample::*f)(void) const;

  p = &Sample::foo;
  instance.*p = 21;
  instanceptr->*p = 42;

  f = &Sample::bar;
  (instance.*f)();
  (instance->*f)();
}
#+END_SRC

Allright, so. The first pointer is straightforward: you declare a
Sample pointer, and initialize its value to the address of another
value.

The syntax for the two other pointers seems complex, but we're just
declaring pointers with some added logical-syntactic sugar. The
~Sample::~ syntax specifies that the pointer MUST be a member of the
class instance.

The ~instance.*p = 21~ syntax means, assign 21 to the value of the ~p~
variable of the instance ~instance~. If you're dealing with a pointer
to a structure, use the -> notation.

Declaring an array of function pointers:
#+NAME: array-of-fpointers
#+BEGIN_SRC C++
  void (Sample::*functions[4])(void) = {
    &Sample::fct1,
    &Sample::fct2,
    &Sample::fct2,
    &Sample::fct4
  };

  for (int i = 0; i < 4; i++) {
    (this->*functions[i])();
  }
#+END_SRC

Still a bit unclear on using them; especially, the use of ~this->~ and
how it maps to the functions. Is it getting the address of that
function for that instance? Gotta figure that out...

** new and delete
Even though malloc is allowed in C++, NEVER use it. Use new and delete
because these functions call, respectively, the object's constructor
and destructor. Here's how you can allocate memory in C++:

#+NAME: memory-allocation
#+BEGIN_SRC C++
class Student {
  private:
    ...
};

int main(void)
{
  Student *jim = new Student("login");
  Student *students = new Student[42];

  // do some stuff
  delete jim;
  delete [] students; // strange syntax, but that's how it works.
  return (0); // classes are destroyed
}
#+END_SRC

One thing to keep in mind, when allocating arrays of structures, it is
IMPOSSIBLE to initialize values at construction. Therefore, you must
find a way around that.

** references
Somewhat similar to pointers, in the sense that it is
pass-by-reference (instead of pass-by-value). Generally, in C++, you
use references when you can, and pointers when you need to. A few
guidelines:
  1) if you want to change the object passed, call by reference or use
     a pointer; e.g., ~void f(int & i) || void f(int * i)~
  2) if you don't want to change the object and it is big, call by
     const reference; e.g., ~void f(const & i)~
  3) otherwise, call by value; e.g. ~void f(int i)~

A reference is a const pointer that is always dereferenced and is
never NULL. The reference is not a copy or a pointer; it IS the
object. From the [[https://isocpp.org/wiki/faq/references#overview-refs][C++ FAQ]]:

#+begin_quote
Even though a reference is often implemented using an address in the
underlying assembly language, please do not think of a reference as a
funny looking pointer to an object. A reference is the object. It is
not a pointer to the object, nor a copy of the object. It is the
object.
#+end_quote

Use references when you want to pass-by-address instead of
pass-by-value.

#+BEGIN_SRC C++
#include <iostream>

int main(void)
{
  int num = 42;

  int& numRef = num;
  std::cout << num << numRef << std::endl;
}
#+END_SRC

#+RESULTS:
: 4242

** filestreams
As we've seen, we can interact with streams like stdout, stdin, and
stderr. All simple enough. And, as in C, you can interact with
filestreams. To do so, we use the ~<fstream>~ header.

#+NAME: filestreams
#+BEGIN_SRC C++
#include <fstream>
#include <iostream>

int main(void) {
  std::ifstream ifs("numbers");
  unsigned int dst;
  unsigned int dst2;

  ifs >> dst >> dst2;
  std::cout << dst << " " << dst2 << std::endl;
  ifs.close();
}
#+END_SRC

The line ~std::ifstream ifs("numbers")~ associates an input file
stream (ifstream) with the (opened) file 'numbers'.

A simple way to read through files. You can redirect output to any
kind of stream.

#+NAME: reading-filestreams
#+BEGIN_SRC C++ :results output
#include <fstream>
#include <string>
#include <iostream>

int main(void) {
  std::ofstream ofs;
  std::ifstream ifs;

  ifs.open("/Users/tgarriss/Projects/42/cpp/01/ex04/somefile.txt");
  ofs.open("/Users/tgarriss/Projects/42/cpp/01/ex04/somefile.replace");
  if (ifs.is_open())
  {
    std::string line;
    while (std::getline(ifs, line))
      ofs << line << std::endl;
  }
  else
    std::cout << "FAILURE!" << std::endl;
  return (0);
}
#+END_SRC

#+RESULTS: reading-filestreams

There are also string streams apparently. Look that up. I've written
some basic info about it in code... But that's not enough. There's
likely an initialization method to interact with a string or
something...

#+NAME: string-streams
#+BEGIN_SRC C++
#include <string>
#include <iostream>
#include <sstream>

int main(void) {
  std::stringstream ss;

  ss << 100 << ' ' << 200;

  int foo,bar;
  ss >> foo >> bar;
  std::cout << foo << std::endl;
  std::cout << bar << std::endl;
}
#+END_SRC

#+RESULTS: string-streams
: 100
: 200
** strings
There's a bunch of neat functions for strings. Look at:
- .compare()
- .size()
- .append()
- .assign()
- .replace()
** switch statements
switch statements are the same in CPP and C. They're straightforward
to use. Simply remember that they fall through:

#+NAME: switch-statements
#+BEGIN_SRC C++
#include <iostream>

int main(void) {
  int i;

  i = 1;
  switch (i) {
    case 1:
      std::cout << "Case 1!" << std::endl;
    case 2:
      std::cout << "Case 2!" << std::endl;
      break;
    case 3:
      std::cout << "Case 3!" << std::endl;

  }
}
#+END_SRC

#+RESULTS: switch-statements
| Case | 1! |
| Case | 2! |

** adhoc polymorphism
adhoc polymorphism (aka function overloading) is a principle in C++
that allows us to use the same name for functions that take different
parameters. A simple example:

#+NAME: adhoc-polymorphism
#+BEGIN_SRC C++ :results output
#include <iostream>

// Sample.class.hpp
class Sample {
  public:
    Sample(void);
    ~Sample(void);

    void bar(char const c) const;
    void bar(int const n) const;
    void bar(float const z) const;
    void bar(Sample const &i) const;
};

// Sample.class.cpp
Sample::Sample(void) {};
Sample::~Sample(void) {};

void Sample::bar(char const c) const {
  std::cout << "char" << std::endl;
}

void Sample::bar(int const n) const {
  std::cout << "int" << std::endl;
}

void Sample::bar(float const z) const {
  std::cout << "float" << std::endl;
}

void Sample::bar(Sample const &i) const {
  std::cout << "sample" << std::endl;
}

// main.cpp
int main(void) {
  Sample s;
  Sample &s2 = s;

  s.bar('a');
  s.bar(42);
  s.bar(4.2f);
  s.bar(s2);
}
#+END_SRC

** operator overloads
Operator Overloading allows us to augment C++ operators; to add on
specific functionalities (like adding two classes together).

There are several ways to write operators in a mathematical
expression: prefix, infix, postfix (~+ 1 1~, ~1 + 1~, ~1 1 +~). The
prefix notation, also called functional syntax because of its
ressemblance to a function call (~+(1, 1)~), is the key to
understanding operator overloads.

Let's imagine that we're working with instances of classes. The same
idea might be expressed as: ~1.+(1)~. From the instance '1', call the
member function '+' with the argument '1'.

Operator Overloads are declared in their respective .hpp files. The
syntax goes like this:

#+NAME: declare-overloads
#+BEGIN_SRC C++ :noweb yes
class Integer {
  public:
    Integer(int const n);
    ~Integer(void);
    int getValue(void) const;
    Integer & operator=(Integer const & rhs);
    Integer operator+(Integer const & rhs) const;
  private:
    int _n;
};

std::ostream & operator<<(std::ostream & o, Integer const & rhs);
#+END_SRC

Some syntax explanations:
  1) The 'operator' keyword and its respective symbol (+-=...) is used
     to declare operator overload functions.
  2) 'rhs' stands for 'right hand side' ('lhs', 'left hand side') of
     the operation. As in, (lhs) 1 + 1 (rhs).
  3) The '+' operator overload function is const because it never
     modifies the instance; e.g. the 1s in '1 + 1' are never modified,
     they return something)
  4) the '=' operator overload function is !const because it modifies
     the instance's value; i.e., it assigns something new to it.
  5) the '=' operator overload function must return a reference to
     itself to accomodate assignation chaining (~a = b = c = d;~).
  6) the '+' operator overload function returns a copy of itself.

This is how they would be implemented:
#+NAME: define-overloads
#+BEGIN_SRC C++ :noweb yes
Integer::Integer(int const n) : _n(n) {}
Integer::~Integer() {}

int Integer::getValue(void) const {
  return (this->_n);
}

Integer & Integer::operator=(Integer const & rhs) {
  this->_n = rhs.getValue();
  return (*this);
}

Integer Integer::operator+(Integer const & rhs) const {
  return (Integer(this->_n + rhs.getValue()));
}

std::ostream & operator<<(std::ostream & o, Integer const & rhs) {
  o << rhs.getValue();
  return (o);
}
#+END_SRC

The stream redirection overload cannot use member functions, since it
cannot modify the std::ostream class (how come?). Therefore, note that
the declaration of the '<<' overload is outside the class definition,
and that there is no ~Integer::~ in the definition.

#+NAME: main-overload
#+BEGIN_SRC C++ :noweb yes :results output
#include <iostream>

<<declare-overloads>>
<<define-overloads>>

int main(void) {
  Integer x(30);
  Integer y(10);
  Integer z(0);

  std::cout << "value of x: " << x << std::endl;
  std::cout << "value of y: " << y << std::endl;
  y = Integer(12);
  std::cout << "newvalue of y: " << y << std::endl;
  std::cout << "value of z: " << z << std::endl;
  z = x + y;
  std::cout << "newvalue of z: " << z << std::endl;
}
#+END_SRC

BEWARE! There are a few rules to maintain conceptual clarity when
writing operator overloads:
  1) it should feel natural
  2) didn't understand the video... well... too bad.
  3) DON'T USE THEM! There are better ways of implementing the same behavior.

You can also overload increment/decrement operators. The syntax is
weird and arbitrary: for postfix increment/decrement, you must pass an
int to the overloading function. e.g.:
#+NAME: incr-decr-overloads
#+BEGIN_SRC C++
// prefix incr
Sample & Sample::operator++(void) {
  this->_value++;
  return (*this);
}

// postfix decr
Sample Sample::operator--(int) {
  Sample tmp;

  tmp = *this;
  --*this;
  return (tmp);
}
#+END_SRC

** canonical form
The canonical form is a norm for writing classes; it is merely for
clarity and consistency. A canonical form contains, at least:
  1) a default constructor
  2) a copy constructor (a constructor that takes another instance to
     become a copy of it).
  3) a '=' operator overload.
  4) a default destructor.
  5) a virtual destructor (to be define later)

As optional, but useful features, think of implementing:
  1) the stream redirection '<<' operator overload
  2) something that serializes your class into a string (like for a
     json object)

#+NAME: canonical-form-declare
#+BEGIN_SRC C++ :noweb yes
class Sample {
  public:
    Sample(void);    // default constructor
    Sample(Sample const & src);    // copy constructor
    ~Sample(void);    // default destructor

    Sample & operator=(Sample const & rhs);    // '=' overload
  private:
    int _value;
};

std::ostream & operator<<(std::ostream & o, Sample const & i);    // optional stream redirection
#+END_SRC

#+NAME: canonical-form-define
#+BEGIN_SRC C++ :noweb yes
Sample::Sample(void) : _value(0) {std::cout << "default constr." << std::endl;}
Sample::Sample(Sample const & src) {
  std::cout << "copy constr" << std::endl;
  *this = src;
  return ;
}

Sample::~Sample(void) {std::cout << "default destr." << std::endl;}

Sample & Sample::operator=(Sample const & rhs) {
  std::cout << "= operator" << std::endl;
  if (this != &rhs)
    this->_value = rhs.getValue();
  return (*this);
}
std::ostream & operator<<(std::ostream & o, Sample const & i) {
  o << "stream redir. value is: " << i.getValue() << std::endl;
  return (o);
}
#+END_SRC

#+RESULTS: canonical-form-declare

#+NAME: canonical-main
#+BEGIN_SRC C++ :noweb yes :results output
<<canonical-form-declare>>
<<canonical-form-define>>

int main(void) {
  Sample instance1;
  Sample instance2(42);
  Sample instance3(instance1);

  std::cout << instance1 << std::endl;
  std::cout << instance2 << std::endl;
  std::cout << instance3 << std::endl;

  instance3 = instance2;
  std::cout << instance3 << std::endl;
  return (0);
}
#+END_SRC
** inheritance
Basically lets you abstract behaviours of a class, and use them in
other classes. This lets you cut down on the amount of redundancy, at
the cost of complexity. Try to limit inheritance to 2 levels.

#+NAME: inheritance
#+BEGIN_SRC C++ :results output
#include <string>

class Animal {
  private:
    int _numOfLegs;
  public:
    Animal();
    Animal(Animal const &);
    Animal & operator=(Animal const &);
    ~Animal(void);

    void run(int distance);
};

class Cat : public Animal {
  public:
    Cat(void);
    Cat(Cat const &);
    Cat & operator=(Cat const &);
    ~Cat();

    void scornSomeone(std::string const & msg);
};

int main(void) {
  Cat cat;

  cat.scornSomeone("Laaaaaaame!");
}
#+END_SRC

You can also override functions from the parent class by defining the
same function in the child.

When declaring a class that inherits from another, you must specify
the type of encapsulation. All the member of the base class are part
of the derived class. However, the derived class can only access
members that are public or protected. In the example above, it is
~public~, but you'll find two others:
1) *public inheritance* makes public members of the base class public in
   the derived class, and the protected members of the base class
   remain protected in the derived class.
2) *protected inheritance* makes the public and protected members of the
   base class protected in the derived class.
3) *private inheritance* makes the public and protected members of the
   base class private in the derived class.

When a derived class is called, its base class is constructed first,
then the derived instance is constructed. When a derived class is
destroyed, the derived class is destroyed first, then its parent
class.
** subtype polymorphism
Subtype polymorphism is basically the same thing as inheritance; it is
often called this, and class subtyping. It implies another logical
concept though, that of relationships between classes.

Run the ~main()~ below, you'll find that you can assign a Warrior
class to a Character object since a Warrior IS-A Character. It does
not work the other way around (a Character IS-NOT-ALWAYS a Warrior).
But, initializing it like that tells the compiler to use the functions
associated with the Character class. Obviously, this only works when
classes are related; the Cat class has no relationship with the
Warrior, nor the Character class, and therefore will throw an error at
compilation.

When classes are meant to be manipulated polymorphically, always make the base class's destructor virtual. What about the derived classes'?

#+NAME: polymorphism-virtual
#+BEGIN_SRC C++ :results output
#include <string>
#include <iostream>

class Character {
  public:
    void sayHello(std::string const & target);
    //virtual void sayHello(std::string const & target);
};

class Warrior : public Character {
  public:
    void sayHello(std::string const & target);
    //virtual void sayHello(std::string const & target);
};

class Cat {
  // ...
};

void Character::sayHello(std::string const & target) {
  std::cout << "Good day, " << target << " !" << std::endl;
}

void Warrior::sayHello(std::string const & target) {
  std::cout << "Go screw yourself, " << target << std::endl;
}

int main(void) {
  Character *a = new Character();
  Character *b = new Warrior();
  Warrior *c = new Warrior();
  Warrior *d = new Warrior();
  //Character *e = new Cat();

  a->sayHello("World");
  b->sayHello("Buttface");
  c->sayHello("Wormguts");
  d->sayHello("Water Buffalo");
  delete a, b, c, d;
}
#+END_SRC

#+RESULTS: polymorphism-virtual
: Good day, World !
: Good day, Buttface !
: Go screw yourself, Wormguts
: Go screw yourself, Water Buffalo

There is a way to get around that though, and it is to use the
~virtual~ keyword on a member function. Change the comments in the
code above to see how this works.

N.B.: 'methods' are virtual member functions.
** abstract classes and interfaces
Abstract classes are classes that cannot be instanciated directly. As
a norm, abstract class names are prefixed with an '*A*', as in ~class
ACharacter~.

An abstract class has one or more 'pure virtual functions'. These are
denoted by adding ~virtual~ keyword, and ending the function
definition with ~public: virtual aFunction(void) = 0;~. This means
that every subclass MUST define this function, but it is NOT defined
in the abstract class.

An interface is an abstract class that contains ONLY pure methods, and
has no attributes. Their names are prefixed with '*I*'. They are used
to conceptualize a class, which can be instantiated by a subclass. It
kinda gives a blueprint to build more complex classes with.
** deep vs shallow copies
A deep copy creates a new object in memory, while a shallow copy
references the original object. Make sure to use whichever one is
appropriate for the case you're working on; e.g.: if you're gonna
modify either of the objects, you'll want a deep copy, if not, stick
to a shallow copy.
** exceptions
Errors in C++ are caught with ~try~ and ~catch~ blocks. Basically, you
try some code in the ~try~ block, and ~throw~ an exception in the if
it fails, then deal with the exception (specific or generic) in the
following ~catch~ blocks.

As a general rule, throwing an exception if ressource demanding. Use
them sparingly, and only when absolutely necessary; consider if a
simpler method might be enough (returning a bool, for example);

#+NAME: exceptions-1
#+BEGIN_SRC C++
#include <stdexcept>
#include <iostream>

void exceptionOne(void) {
  int a = 0;

  try {
    if (a != 1) {
      throw std::exception();
    }
    else {
      // run some code
    }
  }
  catch (std::exception e) {
    std::cout << e.what() << std::endl;
  }
}

int main(void) {
  exceptionOne();
}
#+END_SRC

You can also have ~try~ and ~catch~ blocks in different functions,
like in the example below:

#+NAME: exceptions-2
#+BEGIN_SRC C++
#include <stdexcept>
#include <iostream>

void exceptionTwo(void) {
  int a = 0;
  if (a != 1) {
    throw std::exception();
  }
  else {
    // run some code
  }
}

int main(void) {
  try {
    exceptionTwo();
  }
  catch (std::exception & e) {
    std::cout << e.what() << std::endl;
  }
}
#+END_SRC

We can also define our own exceptions by inheriting from the
std::exception class:

#+NAME: exception-custom
#+BEGIN_SRC C++ :results output
#include <stdexcept>
#include <iostream>

void smash(int i);

class CustomException : public std::exception {
    public:
      virtual const char * what() const throw() {
        return ("Problem exists between keyboard and chair.");
      }
};

void exceptionThree(int i) {
  try {
    smash(i);
  }
  catch (CustomException & e) {
    std::cout << e.what() << std::endl;
  }
  catch (std::exception & e) {
    std::cout << e.what() << std::endl;
  }
}

void smash(int i) {
  if (i == 1) {
    throw CustomException();
  }
  else if (i == 2) {
    throw std::exception();
  }
}

int main(void) {
  exceptionThree(1);
  exceptionThree(2);
}
#+END_SRC

In the example above, the ~throw()~ specifier allows you to specify
which exceptions can be thrown by the attached function. It has been
deprecated in C++11.

One can also define exception classes within a nested class. You can
access them with: ~<CLASS_NAME>::<EXCEPTION_NAME>~.
** TODO casts & conversions
- [ ] Redo this whole section.
In C, you can cast variables to another type. This is great,
sometimes, especially when you're promoting to a new variable type
(one that has bigger storage space than the current one; nt =>
double), but causes problems when assigning to a lesser one (double =>
int). That's due to how they are stored in memory. That's a whole
other subject, for now, suffice to know that it is unwise to cast to a
smaller type, unless you're willing to lose precision (certain types
are more precise than others).

Same thing goes for pointers: demoting is hazardous, promoting is
fine. The most general pointer type is a ~void *~ which can hold any
type of pointer. This is called reinterpretation, which means that no
conversion is applied when promoting or demoting a variable; the bits
are copied as-is.

You can also type cast qualifiers; meaning that you can cast ~int a~
to ~int const *b~, and also the opposite (to make a variable read and
write for example by removing the ~const~).

The same concept applies to classes: a child class is a more precise
version of a parent.

But in C++, we've got a few different options for casting.
*** The Static Cast
Firstly, the ~static_cast~ keyword:

#+BEGIN_SRC C++ :results output
#include <iostream>

int main(void) {
  double a = 42;
  int b = static_cast<int>(a);

  std::cout << b << std::endl;
}
#+END_SRC

The ~static_cast~ keyword can also be used with classes. This keyword
also prevents from casting two unrelated class types as in the example
below:

#+BEGIN_SRC C++
class Parent {};
class Child : public Parent {};
class Unrelated {};

int main(void) {
  Child a;
  Parent * b = &a; // implicit upcast. OK
  Child * c = static_cast<Child *>(b); // explicit upcast
  Unrelated * d = static_cast<Unrelated *>(a);
  // conversions out of hierarchy dont work
}
#+END_SRC

*** The Dynamic Cast
The ~dynamic_cast~ keyword happens at execution time. This means that
a program might compile properly, but still fail at runtime when
calling the dynamic cast. The dynamic cast only works in cases where
there is polymorphism (needs one virtual method). They also only work
on pointers or references.

#+BEGIN_SRC C++ :results output
#include <iostream>

class Parent {public:virtual ~Parent(void) {}};
class Child1 : public Parent {};
class Child2 : public Parent {};

int main(void) {
  Child1 a;
  Parent *b = &a;

  Child1 * c = dynamic_cast<Child1 *>(b);
  if (c == NULL) {
    std::cout << "Conversion failed." << std::endl;
  } else {
    std::cout << "Conversion succeeded." << std::endl;
  }

  try {
    Child2 & d = dynamic_cast<Child2 &>(*b);
    std::cout << "Conversion succeeded." << std::endl;
  } catch (std::bad_cast & bc) {
    std::cout << "Conversion failed." << bc.what() << std::endl;
  }
}
#+END_SRC

Dynamic casting is useful when adding plugins to an application, and
represented as a class. Dynamic Casting allows to verify that the
plugin type is actually the type you're trying to use, and throw an
error instead of crashing...Wow this is super unclear...

*** The Reinterpret Cast
The ~reinterpret_cast~ is the most permissive cast: you can
reinterpret any address to any other address with all the consequences
this entails.

Basically, when you call the ~reinterpret_cast~, the cpu doesn't do
any calculations to change the representation of the bits. Meaning
that, when you convert an ~int *~ to a ~float *~, the new
(dereferenced) value has nothing to do with the old value. BUT! When
you cast it back to its original type, you get the original value.

From [[https://en.cppreference.com/w/cpp/language/reinterpret_cast][cppreference]]:
#+begin_quote
1. A pointer can be converted to any integral type large enough to
   hold all values of its type (e.g. to std::uintptr_t)
2. A value of any integral or enumeration type can be converted to a
   pointer type. A pointer converted to an integer of sufficient size
   and back to the same pointer type is guaranteed to have its
   original value, otherwise the resulting pointer cannot be
   dereferenced safely (the round-trip conversion in the opposite
   direction is not guaranteed; the same pointer may have multiple
   integer representations)
#+end_quote

*** The Const Cast
The ~const_cast~ allows us to transform type qualifiers. But NEVER use
it! If you have to use it, your code probably sucks. (unless one of
the libraries forces you to do so because it was coded like s#!±).

#+BEGIN_SRC C++ :results output
int main(void) {
  int a = 42;

  int const * b = &a; // implicit promotion, ok
  int * c = b; // this fails
  int * d = const_cast<int *>(b); // explicit demotion, ok
}
#+END_SRC
*** Operator Typecasts
Operator Typecasts allow you to define within your classes specific
operators that allow you to convert implicity a class to another type.

#+BEGIN_SRC C++ :results output
#include <iostream>

class Foo {
  public:
    Foo(float const v) : _v(v) {}
    float getV(void) {return (this->_v);}
    operator float() {return (this->_v);}
    operator int() {return static_cast<int>(this->_v);}
  private:
    float _v;
};

int main(void) {
  Foo a(420.042f);
  float b = a;
  int c = a;

  std::cout << a.getV() << std::endl;
  std::cout << b << std::endl;
  std::cout << c << std::endl;
}
#+END_SRC

This allows you to use the ~operator <TYPE>()~ to define how your
class handles being cast to another type.
** explicit keyword
C++ allows cast to happen anywhere during the code, meaning that when
calling a function, your compiler will look inside your class
definition to see if it can convert (construct) it implicitly. Thus,
you can decide when you allow implicit/explicit casts to happen.

#+BEGIN_SRC C++
class A {};
class B {};

class C {
  public:
    C( A const & _ ) {return;};
    explicit C( B const & _) {return;};
};

void f(C const & _) {
  return ;
}

int main(void) {
  f( A() );
  f( B() ); // implicit cast, explicit construct, fails on compile.
  return (0);
}
#+END_SRC
** templates
Templates allow to create blueprints that can be generate by the
compiler to complete them. This allows us to write code that contains
'type variables'. At compilation, these type variables are 'filled in'
with whatever you specify.

Take the following ~max()~ function.

#+BEGIN_SRC C++
#include <iostream>

int max(int x, int y) {
  return (x >= y ? x : y);
}
#+END_SRC

To turn it into a template function, add the ~template~ keyword, and
the name of the type before the function definition. Now, you can pass
variables of any type (including classes and other objects!) to the
function.

#+NAME: fct-template
#+BEGIN_SRC C++ :noweb yes
template< typename T > // for multiple types: < typename T, typename Y, ... >
T max(T x, T y) {
  return (x >= y ? x : y);
}
#+END_SRC

When passing voluminous classes, consider using references instead of
values, e.g.: ~T max(T & x, T & y) {...}~. AND! if you're not modyfing
any values remember to make the references ~const~! (~T const & max(T
const & x, T const & y) {...}~).

#+BEGIN_SRC C++ :noweb yes :flags -Wall -Wextra -Werror -std=c++98 :results output
#include <iostream>
<<fct-template>>

int main(void) {
  int a = 21;
  int b = 42;

  // explicit instanciation
  std::cout << "Max of a and b: " << max<int>(a, b) << std::endl;
  // implicit instanciation
  std::cout << "Max of a and b: " << max(a, b) << std::endl;

  float c = 21.42f;
  float d = 42.21f;

  // explicit instanciation
  std::cout << "Max of c and d: " << max<float>(c, d) << std::endl;
  // implicit instanciation
  std::cout << "Max of c and d: " << max(c, d) << std::endl;
}
#+END_SRC

We can also write template classes:

#+BEGIN_SRC C++

#include <iostream>
template<typename T >
class List {
  public:
    List<T>(T const & content) {}
    List<T>(List<T> const & list) {}
    ~List<T>(void) {}
  private:
    T _content;
    List<T> * _next;
};

int main(void) {
  List<int> a(42);
  List<float> b(3.14f);
  List<List<int>> c(a);
}
#+END_SRC

Now for a complete template example. Template classes might be placed
in a file called ~<NAME>.class.tpp~.

#+BEGIN_SRC C++ :results output
#include <iostream>
#include <iomanip>

// this is a default type. Basically, it says: if nothing is
// specified, assume it is float
template< typename T = float >
class Vertex {
  public:
    Vertex(T const & x, T const & y, T const & z) : _x(x), _y(y), _z(z) {}
    ~Vertex(void) {}

    T const & getX() const {return (this->_x);};
    T const & getY() const {return (this->_y);};
    T const & getZ() const {return (this->_z);};
  private:
    T const _x;
    T const _y;
    T const _z;

  // the default constructor is private, which means that this class
  // must be instantiated using the (x, y, z) constructor.
    Vertex(void);
};

template< typename T>
std::ostream & operator<<(std::ostream & o, Vertex< T > const & v) {
  std::cout.precision(1);
  o << std::setiosflags(std::ios::fixed);
  o << "Vertex( ";
  o << v.getX() << ", ";
  o << v.getY() << ", ";
  o << v.getZ();
  o << " )";
  return (o);
}

int main(void) {
  Vertex<int> a(1, 2, 3);
  Vertex<> b(12, 23, 34);

  std::cout << a << std::endl;
  std::cout << b << std::endl;
}
#+END_SRC

Specializations allow us to define specific behaviour when
encountering a specfic type. These can be partial, or complete.
Partial would redefine at least one of the typenames; complete, would
redefine all of them.

First define the base class. then, define its specializations:

#+NAME: specialization-full-ex
#+BEGIN_SRC C++ :flags -Wall -Wextra -Werror -std=c++98 :noweb yes
#include <iostream>
#include <iomanip>

template<typename T, typename U>
class Pair {
  public:
    Pair< T, U>(T const & lhs, U const & rhs) : _lhs(lhs), _rhs(rhs) {
      std::cout << "Generic Template" << std::endl;
    }
    ~Pair<T, U>(void) {}

    T const & fst(void) const {return this->_lhs;}
    U const & snd(void) const {return this->_rhs;}
  private:
    T const & _lhs;
    U const & _rhs;

    Pair<T, U>(void);
};

template<typename T, typename U>
std::ostream & operator<<(std::ostream & o, Pair<T, U> const & p) {
  o << "Pair(  " << p.fst() << ", " << p.snd() << " )";
  return (o);
}

// ===== int partial specialization ==================================

template<typename U>
class Pair<int, U> {
  public:
    Pair< int, U>(int const & lhs, U const & rhs) : _lhs(lhs), _rhs(rhs) {
      std::cout << "Int Partial Specialization" << std::endl;
    }
    ~Pair<int, U>(void) {}

    int const & fst(void) const {return this->_lhs;}
    U const & snd(void) const {return this->_rhs;}
  private:
    int const & _lhs;
    U const & _rhs;

    Pair<int, U>(void);
};

#+END_SRC

Complete specializations allow you to define very specific behaviour
for a specific case. You can radically alter how a class works. Like
in the case of a ~Pair(bool, bool)~ complete specialization. Since the
value of two bools can be easily stored in an ~int~ variable.

#+BEGIN_SRC C++ :flags -Wall -Wextra -Werror -std=c++98 :noweb yes :results output
<<specialization-full-ex>>
// ===== bool complete specialization ================================
template<>
class Pair<bool, bool> {
  public:
    Pair<bool, bool>(bool lhs, bool rhs) {
      std::cout << "bool/bool specialization" << std::endl;
      this->_n = 0;
      this->_n = static_cast<int>(lhs) << 0;
      this->_n = static_cast<int>(rhs) << 1;
      return ;
    }
    ~Pair<bool, bool>(void) {};

    bool fst(void) const {return (this->_n & 0x01); }
    bool snd(void) const {return (this->_n & 0x01); }
  private:
    int _n;
    Pair<bool, bool>(void);
};

template<>
std::ostream & operator<<(std::ostream & o, Pair<bool, bool> const & p) {
  o << std::boolalpha << "Pair(  " << p.fst() << ", " << p.snd() << " )";
  return (o);
}

int main(void) {
  Pair<int, int>a(4, 2);
  Pair<std::string, float>b(std::string("Pi"), 3.14f);
  Pair<float, bool>c(4.2f, true);
  Pair<bool, bool>d(true, false);
  std::cout << a << std::endl;
  std::cout << b << std::endl;
  std::cout << c << std::endl;
  std::cout << d << std::endl;
  return (0);
}
#+END_SRC
** standard template library
The STL contains a bunch of containers that are templated:
 1) std::list<int>
 2) std::map<std::string, int>
 3) std::vector<int>
 4) ...

These containers have access to a bunch of functions. Namely,
iterators. Just look it up.

Maps are like python dictionnaries (key, value pairs).

The algorithm library allows you to use stuff that can help manipulate
data... For example, ~for_each~, which you can use:

#+BEGIN_SRC C++
#include <iostream>
#include <algorithm>
#include <list>

void displayInt(int i) {
  std::cout << i << std::endl;
}

int main(void) {
  std::list<int> lst;

  for (int i = 0; i < 10; i++) {
    lst.push_back(i);
  }
  for_each(lst.begin(), lst.end(), displayInt);
  return (0);
}
#+END_SRC

