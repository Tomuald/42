:PROPERTIES:
#+title: Notes
:END:

A collection of notes concerning 42 Projects.

* C++
** files & extensions
Files in cpp use the .cpp/.hpp extensions. It makes it easier for
compilators usually. When defining or declaring a class inside a file,
use: <NAME>.class.cpp/.hpp.
** classes
A basic class is declared in an .hpp file, like this:

#+NAME: basic-class-declare
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C
class Sample
{
public:
  Sample(void);
  ~Sample(void);
};
#+END_SRC

Sample() and ~Sample() are the class's constructor and destructor.
They both have no return type, since they are procedures and not
really functions. The constructor is called as soon as you instanciate
a class. If defined locally, the class's destructor is called when the
function reaches it return() call.

#+NAME: basic-class-define
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C
#include "Sample.class.hpp"

Sample::Sample(void)
{
  return ;
}

Sample::~Sample(void)
{
  return ;
}
#+END_SRC

To initialize an instance of class:
#+NAME: basic-class-instance
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C
#include "Sample.class.hpp"

int main(int argc, char **argv)
{
  Sample    instance;

  return (0);
}
#+END_SRC

Instances of a class are simple: they're like any other old variable
or struct; they're objects; think of the mold/cake allegory.
** member attributes and functions
These are variables and functions defined in the body of a class.

#+NAME: member-attr-func
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C
// Sample.class.hpp
class Sample(void)
{
public:
  Sample();
  ~Sample();

  int i;
  int is_active(void);
};

// Sample.class.cpp
#include "Sample.class.hpp"

// Constructor()
// ~Destructor()

// See section of the this-> keyword.
int Sample::is_active(void)
{
  if (this->i)
    return (1);
  return (0);
}

// main.c
#include "Sample.class.hpp"

int main(void)
{
  Sample instance;

  instance.i = 1;
  instance.is_active();
  return (0);
}
#+END_SRC
** this-> keyword
The this-> keyword is a pointer to the current instance. It's useful when defining a class. Take a basic class:

#+NAME: basic-this
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C
class Sample
{
public:
  Sample(void);
  ~Sample(void);
  int i;
  int c;
  int set_c(void);
};
#+END_SRC

#+NAME: basic-this-2
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C
#include "Sample.class.hpp"

Sample::Sample(void)
{
  this->i = 42;
  set_c();
  return ;
}

int Sample::set_c(void)
{
  this->c = 24;
  return (0);
}
#+END_SRC
** initialization lists
Initialization lists allow you to succintly setup variables during a
class's construction. Given the class below:

#+NAME: init-lists
#+HEADER: :noweb yes :main no
#+BEGIN_SRC C
// Sample.class.hpp
class Sample
{
public:
  char a1;
  int a2;
  float a3;

  Sample(char p1, int p2, float p3);
  ~Sample(void);
};

// Sample.class.cpp
#include "Sample.class.hpp"

Sample::Sample(char p1, int p2, float p3) : a1(p1), a2(p2), a3(p3)
{
  return ;
}
#+END_SRC

The format ~: a1(p1), a2(p2), a3(p3)~ sets the variable aX to the
value pX implicitly.

Initialization lists can be much more complex than this. We'll dive
into more detail later on.
** const keyword
const keyword are great. They allow to set values that will NEVER be
allowed to be modified or assigned to. It might be the difference
between a working program and a program that fucks up royally. Make
sure to use these keywords freely when writing C++ code; it will make
it more robust, and harder to break.

Since const variables can NEVER be assigned a value, we need to bypass
that by initializing them with the same concept of [[initialization lists][initialization lists]].

#+NAME: const-init
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
// Sample.class.hpp
class Sample
{
public:
  float const pi;
  int qd;

  Sample(float const f);
  ~Sample(void);

  void bar(void) const;
};

// Sample.class.cpp
Sample::Sample(float const f) : pi(f)
{
  return ;
}

void Sample::bar(void) const
{
  return ;
}
#+END_SRC

The difference is subtle, but here, we are INITIALIZING the variable,
not assigning to them.

We snuck in a const somewhere in the .hpp that might seem unusual:
~void bar(void) const~. This const applies to the function itself, and
means that NOWHERE in it's body will there be any type of assignation
to the members attributes of the class (no ~this->a = 42~, etc).
** visibility (public vs private)
public vs private keywords restrain which attributes/functions are
accessible from within and outside the class. Private attrs/fcts are
INnaccesible from outside the class; whereas public ones can be
accessed from anywhere. Basically, think of the public attrs as the
ones that your user can access, and private ones as the ones your code
can access.

There is a convention to use the underscore (_var || var _) to
highlight private attributes. Its purpose is to make the code easier
to read, and understand at a glance, which is private, which is
public.

#+NAME: visibility
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
class Sample
{
private:
  const int i;
public:
  Sample(void);
  ~Sample(void);
};
#+END_SRC
** accessors
accessors are functions that allow to retrieve the values of your
private attributes (get() and set() functions).

Naming conventions are get<Attrb>(), set<Attrb>().

#+NAME: accessors
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
// Sample.class.hpp

class Sample
{
public:
  Sample(void);
  ~Sample(void);
  int getFoo(void) const;
  void setFoo(int v);
private:
  int _foo;
};

// Sample.class.
int Sample::getFoo(void) const {
  return this->_foo;
}

void Sample::setFoo(int v) {
  this->_foo = v;
}
#+END_SRC
** comparisons
In C++, structures and classes are no longer compared by addresses;
which means that you can compare structs/classes by value. But, to do
that, you have to set up a few things.

#+NAME: comparisons
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
// Sample.class.hpp

class Sample {
public:
  Sample(int v);
  ~Sample(void);

  int getFoo(void) const;
  int compare(Sample *other) const;

private:
  int _foo;
};

// Sample.class.cpp
#include "Sample.class.hpp"

int Sample::compare(Sample *other) const {
  if (this->_foo < other->getFoo())
    return (-1);
  else if (...)
    return (1);
  return (0);
}
#+END_SRC

So, basically, you have to implement that manually... That's not
really much better.
** non-member attributes and functions
Classes also have non-member attributes and functions (class attrs/fcts); these operate at the class-level, instead of at the instance-level.

The static keyword means something different in C++. It is used to
declare non-member attributes and functions.

#+NAME: non-member
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
// Sample.class.hpp

class Sample {
public:
  // Const/Dest
  static int getNbInst(void);
private:
  static int _nbInst;
};

// Sample.class.cpp

Sample::Sample(void) {
  Sample::_nbInst += 1;
}

int Sample::getNbInst(void) {
  return (Sample::_nbInst);
}

int Sample::_nbInst = 0;
#+END_SRC

Here, it makes no sense to have a nbInst variable at the instance
level, because, obviously, you want to know how many instances have
been instantiated; so, class-level stuff.

Also, the this-> keyword is unavailable in non-member functions and
attributes; which makes sense, because you'Re not operating at the
instance level (therefore 'this->' doesn't exist'). But, you can use
the ~<CLASS_NAME>::<VARIABLE>~.

Kinda confusing, but the last line is the only way we have to
initialize a static (non-member attribute). In order, to increment it,
we do it when a constructor of this class is called, and decrement it
when the constructor is called.
** pointers to member attributes and functions
So... Pointers...

#+NAME: pointers-member
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
// Sample.class.hpp

class Sample {
public:
  int foo;
  // Destr/Constr
  void bar(void) const;
};

// Sample.class.cpp

// main.c
int main(void) {
  Sample instance;
  Sample *instanceptr = &instance;
  int Sample::*p = NULL;
  void (Sample::*f)(void) const;

  p = &Sample::foo;
  instance.*p = 21;
  instanceptr->*p = 42;

  f = &Sample::bar;
  (instance.*f)();
  (instance->*f)();
}
#+END_SRC

Allright, so. The first pointer is straightforward: you declare a
Sample pointer, and initialize its value to the address of another
value.

The syntax for the two other pointers seems complex, but we're just
declaring pointers with some added logical-syntactic sugar. The
~Sample::~ syntax specifies that the pointer MUST be a member of the
class instance.

The ~instance.*p = 21~ syntax means, assign 21 to the value of the ~p~
variable of the instance ~instance~. If you're dealing with a pointer
to a structure, use the -> notation.
** new and delete
Even though malloc is allowed in C++, NEVER use it. Use new and delete
because these functions call, respectively, the object's constructor
and destructor. Here's how you can allocate memory in C++:

#+begin_src C
class Student {
  private:
    ...
};

int main(void)
{
  Student *jim = new Student("login");
  Student *students = new Student[42];

  // do some stuff
  delete jim;
  delete [] students; // strange syntax, but that's how it works.
  return (0); // classes are destroyed
}
#+end_src

#+RESULTS:

One thing to keep in mind, when allocating arrays of structures, it is
IMPOSSIBLE to initialize values at construction. Therefore, you must
find a way around that.
** references
Somewhat similar to pointers.

A reference is a const pointer that is always dereferenced and is
never NULL.

#+begin_src C
#include <iostream>

int main(void)
{
  int num = 42;

  int& numRef = num;
  std::cout << num << numRef << std::endl;
}
#+end_src

#+RESULTS:
