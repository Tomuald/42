#+title: Irc_research

* To Do List
** DONE Finish the registration process
** TODO Return correct error messages
** TODO Build the commands
*** TODO nick
*** TODO pass
*** TODO user
*** TODO join
*** TODO pong
*** TODO ping
*** TODO prvmsg
*** TODO oper
*** TODO mode
*** TODO kick
*** TODO ban
*** TODO invite
*** TODO topic
*** TODO op
*** TODO deop
** TODO Complete the Channel class
** TODO Complete the Server class
*** TODO add server_name
*** TODO add hostname
** DONE Split the main server loop
** TODO Clean up code
** TODO Fix CLRF on input
This is trickier than it seems at first...

Implement a loop like getnextline() and modify your code so that each
client gets their own buffer. Pretty simple, messages should not
exceed 510 characters; double-check that in the refs.
** TODO Fix user already exists when connecting to server
* reading notes
A server continually waits for incoming connections; that's what's
called 'listening'. It is done on an IP address and a port number. The
client sends requests to the server.

Both the server and client use an IP and a port number.

When developping Network Programs, the port number of the server is
usually specified within the code (in our case, as one of the
program's argument); the client's port number is allocated by the OS.

The usual flow goes like this:
  1) create a socket - socket()
  2) bind it: bind()
  3) listen for incoming connections: listen()
  4) accept the client: accept(), connect()
  5) send and receive data: recv(), send()
  6) disconnect: closesocket()

Sockets are two-way, data can be sent and received.

Definition: SOCKET: A pipe between two computers on a network through
which data flows.

The server uses a socket to listen for incoming client requests; the
client creates a socket with the info (IP, port) for the server.

UDP is faster but less secure; TCP is more reliable.

When a connection is accepted, the server creates a duplicate new
socket (the server connection) that is used to communicate; the
original socket is preserved, and continues listening for other
connections. That allows multiple clients to connect to the server.

Remember to close the sockets when you're done.

bind() associates a local address with a socket.

the sockaddr_in struct: holds attributes to specify an endpoint
address to which connect a socket (addr family, port, IP, ); used with
bind().

listen() takes a bound, unconnected socket, and a backlog, and int
specifying the maximum number of connections allowed.

accept() is a blocking function. it permits an incoming connection on
a socket. Takes the server socket, (optional, often NULL) a sockaddr
struct which holds info about the client, (optional, often NULL) size
of the struct. Returns a new socket that is connected to the client.

The client also creates its own socket, then it connects to the server
(specify a sockaddr struct), then sends or receives information.

send() sends data on a connected socket. Takes a *connected* socket, a
pointer to a buffer to the data that you wanna transmit, the length of
the buffer, optional set of flags that influence the behaviour. It
returns the number of bytes sent or SOCKET_ERROR, apparently,
sometimes it won't send everything so you have to check for that. Both
the client and server can send stuff.
