:PROPERTIES:
#+title: 42Qu√©bec - Cub3D
#+author: Thomas Garriss
#+STARTUP: show2levels
:END:

* Project Brief
Stuff.
* Requirements
There are two essential components to the Cub3D project: the Parser,
and the 'Graphics Engine'.

** [?] error management
I would like to print better error messages. But how? I thought about
the enum fix, but I don't think it's gonna work out...
** [0/2] compilation & headers
Compilation needs to happen with minilibx. Build it from source. For
Mac and Linux.
*** TODO Makefile
#+NAME: makefile
#+HEADER: :exports code :mkdirp yes :results none :main no
#+HEADER: :tangle Source/Makefile
#+BEGIN_SRC makefile
SRCS	=	main.c utils.c parse.c keypress.c

%.o: %.c
	$(CC) -Wall -Wextra -Werror -I/usr/include -Imlx-linux -O3 -c $< -o $@

OBJS = ${SRCS:.c=.o}

NAME = project.a

PROGRAM = program

CC = gcc

CFLAGS = -Wall -Wextra -Werror -g

RM = rm -Rf

MLX_MAC = -Lmlx-mac -lmlx -framework OpenGL -framework AppKit

MLX_LIN = -I./mlx-linux -L./mlx-linux -lmlx -L. -lX11 -lXext -lm -lbsd

OS_NAME := $(shell uname -s | tr A-Z a-z)

	ifeq ($(OS_NAME), linux)
	MLX = ${MLX_LIN}
	MLX_FOL = mlx-linux
else
	MLX = ${MLX_MAC}
	MLX_FOL = mlx-mac
endif

${NAME}: ${OBJS} main.c
	make -C libft/
	cp libft/libft.a lib${NAME}
	ar rcs lib${NAME} ${OBJS}
	make -C ${MLX_FOL}
	${CC} ${CFLAGS} main.c -L. -l$(basename ${NAME}) ${MLX} -o ${PROGRAM}

all: ${NAME}

clean:
	${RM} ${OBJS}

fclean: clean
	@make fclean -C libft/
	@make clean -C ${MLX_FOL}/
	${RM} lib${NAME} ${PROGRAM}

re: fclean all

.PHONY: all bonus clean fclean re
#+END_SRC
*** TODO Header
#+NAME: header-cub3d
#+HEADER: :exports code :mkdirp yes :results none :main no
#+HEADER: :tangle Source/includes/cub3d.h
#+BEGIN_SRC C
#ifndef CUB3D_H
# define CUB3D_H

# include "../libft/includes/libft.h"
//# include "../mlx-linux/mlx.h"
# include "../mlx-mac/mlx.h"

/*--- Structures ---*/
typedef struct s_point
{
  int x;
  int y;
  char value;
} t_point;

typedef struct s_map
{
  char **textures;
  char **map;
  int ccolor;
  int fcolor;
  int height;
  int width;
  int size;
} t_map;

typedef struct s_player
{
  char direction;
  int x;
  int y;
} t_player;

typedef struct	s_data
{
  void	*mlx;
  void	*window;
  t_map	*map;
  t_player	*player;
}	t_data;

/*--- Functions ---*/

/*--- utils.c ---*/
int destroy_window(t_data *data);
int handle_keypress(int keysym, t_data *data);
int convert_to_rgb(char *r, char *g, char *b);
void print_structure(t_data *data);
char *get_wall(int index);

/*--- parse.c ---*/
int parser(char *filepath, t_data *data);

/*--- UNSORTED ---*/
int forge_structure(char **array, t_data *data);
char **tokenize(char *line);
int set_tokens(char **tokens, t_data *data);
int parse_map(char **tokens, int *i, t_data *data);
int calculate_dimensions(char **tokens, int *i, t_data *data);
int check_map_integrity(t_data *data);
int setup_mlx(t_data *data);

#endif
#+END_SRC

** [3/4] program initialization & main
+ CHECKLIST
  + [ ] add graphics rendering hook.
  + [X] add memory cleanup

The main program is pretty straight forward. It needs to parse a file
into a data structure, and pass it to the graphics engine. Meanwhile,
it has to set up keyhooks to listen for key presses. It also needs to
initialize some components to use the graphics library provided for
the project. Straightforward enough.

*** TODO init struct & mlx

The struct needs to have some memory alloc'd in order to work
properly.

#+NAME: init-struct
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
t_data *init_struct(void)
{
  t_data *data;

  data = ft_calloc(1, sizeof(t_data));
  data->map = ft_calloc(1, sizeof(t_map));
  data->map->map = NULL;
  data->map->textures = ft_calloc(4, sizeof(char *));
  data->player = ft_calloc(1, sizeof(t_player));
  if (setup_mlx(data) == EXIT_FAILURE)
    return (NULL);
  return (data);
}
#+END_SRC

Some basic setup to init a window, and get minilibx running. Expand
its implementation as needed.

#+NAME: setup-mlx
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int setup_mlx(t_data *data)
{
  data->mlx = mlx_init();
  data->window = mlx_new_window(data->mlx, 500, 600, "cub3d");
  return (EXIT_SUCCESS);
}
#+END_SRC

*** DONE initial error checking
Initialization errors are pretty simple for this project. If there are
too few or too many arguments, give an usage-error.

We also need to call the structure initialization, and check if it
succeeded.

#+NAME: initial-error
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
t_data	*data;

if (argc != 2)
  ft_error("Error\nusage: './cub3d <path.cub>'", __FILE__, __func__, __LINE__);
data = init_struct();
if (!data)
{
  ft_printf(STDERR_FILENO, "Error\ninitialization failed.\n");
  return (-1);
}
#+END_SRC

*** DONE calling the parser
We'll get back to the parser's implementation later. Suffice to know,
for now, that we want to check if it runs successfully or not.

#+NAME: parser-start
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
if (parser(argv[1], data) == EXIT_FAILURE)
{
  ft_printf(STDERR_FILENO, "Error\nInvalid map.\n");
  memclean(data);
  return (EXIT_FAILURE);
}
#+END_SRC

*** TODO hooks
We need to add several hooks to our project: our keypress events, our
graphics rendering loop, and, for some reason, we need a special hook
to exit cleanly with the window's x-button (exit with the ESC takes
place in the keypress-events, see section below). And also, gotta
clean up after execution.

#+NAME: hook-setup
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
mlx_hook(data->window, 17, 0, destroy_window, data);
mlx_hook(data->window, 2, 0, handle_keypress, data);
mlx_loop(data->mlx);
memclean(data);
return (EXIT_SUCCESS);
#+END_SRC

** [0/1] keypresses
+ [-] CHECKLIST
  + [X] ESC Key
  + [ ] Player Movemement (WASD)
  + [ ] Camera Movement (<- ->)

Several keybinds need to be set: The ESC key cleanly quits the
program; WASD moves the character's point of view, and L- and R-arrows
rotates the camera left and right.

*** TODO handling keypresses
#+NAME: handle-keypress
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int handle_keypress(int keysym, t_data *data)
{
  // deal with ESC key
  if (keysym == 53)
    destroy_window(data);
  else
    ft_printf(STDERR_FILENO, "%d\n", keysym);
  return (0);
}
#+END_SRC

** [3/5] parsing & initialization
+ [-] CHECKLIST
  + [-] error checking
    + [X] invalid filepath
    + [X] inaccessible file
    + [X] cannot open
    + [ ] add error messages
  + [X] add player position to data struct

Basically, a parser looks at data, checks it for errors, then creates
a data structure out of it, and validates that the info in the struct
is valid. There is gonna be error checking at multiple levels of the
code; that's OK. Keep in mind that errors should print when
encountered; but the program should only exit when returning to the
main() with an EXIT_FAILURE from the parser. From the subject pdf: "if
any errors are encountered, the program must quit and print 'Error\n'
followed by an explicit error message".

We'll assume that informing the user that the parser component failed
is explicit enough; that's a message we can print from the main. We'll
keep other kinds of error messages to a minimum.

*** DONE parser
The parser needs to feed back its exit value to the main(). It does
little but call parsing functions and return exit codes.

#+NAME: parser
#+HEADER: :exports code :mkdirp yes :results none :main no
#+HEADER: :noweb yes
#+BEGIN_SRC C
int parser(char *filepath, t_data *data)
{
  char **array;

  if (check_filepath(filepath) == EXIT_FAILURE)
    return (EXIT_FAILURE);
  array = read_file(filepath);
  if (!array)
    return (EXIT_FAILURE);
  if (forge_structure(array, data) == EXIT_FAILURE)
    return (EXIT_FAILURE);
  if (set_player(data) == EXIT_FAILURE)
    return (EXIT_FAILURE);
  if (validate_data(data) == EXIT_FAILURE)
    return (EXIT_FAILURE);
  print_structure(data);
  return (EXIT_SUCCESS);
}
#+END_SRC

*** DONE filepath validation
The Parser begins by checking if a '.cub' file was passed, then it
checks if it is accessible for reading.

#+NAME: check-filepath
#+HEADER: :exports code :mkdirp yes :results none :main no
#+HEADER: :noweb yes
#+BEGIN_SRC C 
int check_filepath(char *filepath)
{
  int len;

  len = ft_strlen(filepath);
  if (ft_strncmp(&filepath[len - 4], ".cub", 4) != 0)
  {
    ft_printf(STDERR_FILENO, "Error\ncub3d reads .cub maps\n");
    return (EXIT_FAILURE);
  }
  if (access(filepath, R_OK) == -1)
  {
    ft_printf(STDERR_FILENO, "Error\ncannot access() map\n");
    return (EXIT_FAILURE);
  }
  return (EXIT_SUCCESS);
}
#+END_SRC

*** DONE file reading
Then, it stores the file contents into an array for further
processing.

#+NAME: read-file
#+HEADER: :exports code :mkdirp yes :results none :main no
#+HEADER: :noweb yes
#+BEGIN_SRC C
char **read_file(char *filepath)
{
  char **array;
  char *line;
  int fd;

  array = NULL;
  if (!filepath)
    return (NULL);
  fd = open(filepath, O_RDONLY);
  if (fd == -1)
    return (NULL);
  line = get_next_line(fd);
  while (line)
  {
    array = ft_add_to_sarray(array, line, 1);
    line = get_next_line(fd);
  }
  close(fd);
  return (array);
}
#+END_SRC

*** TODO forging data structure
Now for creating the data structure...

The forging-machine loops through the array passed as an argument. It
does a NULL-check, then takes every line in the array, and checks if
it is the map. If it's not, it tokenizes the string ('cause we can
ignore spaces here); if it is the map, it converts spaces to 1s. If
the parser hits an unrecognized token, it prints an error but doesn't
exit.

#+NAME: forge-structure
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int forge_structure(char **array, t_data *data)
{
  char **tokens;
  int i;

  if (!array || !data)
    return (EXIT_FAILURE);
  i = 0;
  while (array[i])
  {
    if (is_map(array[i]) == EXIT_FAILURE)
    {
      tokens = tokenize(array[i]);
      set_tokens(tokens, data);
      ft_free_carray(tokens);
    }
    else if (is_map(array[i]) == EXIT_SUCCESS)
      parse_map(array, &i, data);
    else
      ft_perror("unknown map setting", __FILE__, __func__, __LINE__);
    if (array[i])
      i++;
  }
  ft_free_carray(array);
  return (EXIT_SUCCESS);
}
#+END_SRC

I've decided that I found my map when every other token check was
failed, and it contains a digit.

+ CHECKLIST
  + [ ] cleanup the code

#+NAME: is-map
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int is_map(char *line)
{
  int i;
  int j;

  if (!line)
    return (EXIT_FAILURE);
  i = 0;
  while (line[i])
  {
    while (line[i] && ft_isspace(line[i]))
      i++;
    j = -1;
    while (++j < 4)
      if (ft_strncmp(&line[i], get_wall(j), 2) == 0)
        return (EXIT_FAILURE);
    if (ft_strncmp(&line[i], "F", 1) == 0)
      return (EXIT_FAILURE);
    else if (ft_strncmp(&line[i], "C", 1) == 0)
      return (EXIT_FAILURE);
    else if (ft_isdigit(line[i]))
      return (EXIT_SUCCESS);
    else
      return (-1);
    if (line[i])
      i++;
  }
  return (EXIT_SUCCESS);
}
#+END_SRC

Now tokenize() works for everything that is not the map. It is a very
straightforward tokenization algorhythm: it creates a token at spaces
and commas.

+ [ ] Add other delimiting characters?

#+NAME: tokenize
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
char **tokenize(char *line)
{
  char **tokens;
  char *token;
  int i;

  if (!line)
    return (NULL);
  i = 0;
  tokens = NULL;
  while (line[i])
  {
    token = NULL;
    while (line[i] && !ft_isspace(line[i]) && !ft_isinset(line[i], ","))
      token = ft_add_to_s(token, line[i++]);
    if (token)
      tokens = ft_add_to_sarray(tokens, token, 1);
    i++;
  }
  return (tokens);
}
#+END_SRC

Aight, setting tokens is easy now. Just going through my list of
attributes, and setting them as needed.

What happens when this function encounters an unknown token? Right
now? Nothing. Do I want to make it do something?

#+NAME: set-tokens
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int set_tokens(char **tokens, t_data *data)
{
  int i;
  int j;
  int color;
  
  if (!tokens || !data)
    return (EXIT_FAILURE);
  i = 0;
  while (tokens[i])
  {
    if (!tokens[i + 1])
      return (EXIT_FAILURE);
    j = -1;
    while (++j < 4)
      if (ft_strncmp(tokens[i], get_wall(j), 2) == 0)
	data->map->textures[j] = ft_strdup(tokens[(i++) + 1]);
    if (ft_isinset('F', tokens[i]) || ft_isinset('C', tokens[i]))
    {
      color = convert_to_rgb(tokens[i + 1], tokens[i + 2], tokens[i + 3]);
      if (ft_strncmp(tokens[i], "F", 1) == 0)
	data->map->fcolor = color;
      else if (ft_strncmp(tokens[i], "C", 1) == 0)
	data->map->ccolor = color;
      i += 2;
    }
    i++;
  }
  return (EXIT_SUCCESS);
}
#+END_SRC

+ CHECKLIST
  + [ ] move from char** map to t_point** map?

The .cub map can contain spaces, and these spaces need to be dealt
with properly. On top of that, the map does NOT need to be square to
be valid; but it's gonna make our lives way easier, so we'll hammer it
square (rectangular, whatever). (Actually, from a resources
standpoint, it might be more efficient to not render spaces; but I
think having an even map will make the flood-fill algorithm easier to
implement. See [[validating the data structure][the section]] below).

#+NAME: parse-map
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int parse_map(char **tokens, int *i, t_data *data)
{
  char *line;
  
  if (!tokens || !data || !i)
    return (EXIT_FAILURE);
  if (calculate_dimensions(tokens, i, data) == EXIT_FAILURE)
    return (EXIT_FAILURE);
  while (tokens[(*i)])
  {
    line = fill_line(tokens[*i], data->map->width);
    data->map->map = ft_add_to_sarray(data->map->map, line, 1);
    (*i)++;
  }
  return (EXIT_SUCCESS);
}
#+END_SRC

In order to make our map square, we need its maximum height and
width. Height is easy, just count the number of rows in the array. For
the columns, we need a bit more (see below).

If width or height are negative values or 0, then something messed up.

#+NAME: calculate-dimensions
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int calculate_dimensions(char **tokens, int *i, t_data *data)
{
  int height;

  height = *i;
  while (tokens[height])
    height++;
  data->map->height = height - *i;
  data->map->width = find_longest_line(tokens, i) - 1;
  if (data->map->height <= 0 || data->map->width <= 0)
    return (EXIT_FAILURE);
  data->map->size = data->map->height * data->map->width;
  return (EXIT_SUCCESS);
}
#+END_SRC

To find the width, we need a simple search algorithm that loops
through the array, and checks each item's length; if it's greater than
the previous value, it updates longest_line.

#+NAME: find-longest-line
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int find_longest_line(char **tokens, int *i)
{
  int len;
  int j;

  j = (*i);
  len = ft_strlen(tokens[j]);
  while (tokens[j])
  {
    if ((int) ft_strlen(tokens[j]) > len)
      len = ft_strlen(tokens[j]);
    j++;
  }
  return (len);
}
#+END_SRC

Now that we have our map dimensions, we can fill in our spaces. We
start by looping through the string, duplicating characters: whitespace
is converted to walls ('1'), and other characters are taken as-is.

If this resulting string is shorter than the longest line of our map,
we need to right-pad it with 1s to make it even/square/rectangular/...

Things were fucking up because my ft_isspace() converts '\n' too, so I
always had an extra character at the end. So... I added a check to the
while loop.

#+NAME: fill-line
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
char *fill_line(char *line, int longest)
{
  char *filled;
  int diff;
  int i;

  if (!line)
    return (NULL);
  i = 0;
  filled = NULL;
  while (line[i] && i < (int)ft_strlen(line) - 1)
  {
    if (ft_isspace(line[i]))
      filled = ft_add_to_s(filled, '1');
    else
      filled = ft_add_to_s(filled, line[i]);
    i++;
  }
  diff = longest - ft_strlen(filled);
  if (diff > 0)
    while (diff--)
      filled = ft_add_to_s(filled, '1');
  return (filled);
}
#+END_SRC

Setting the player. Easy peasy.

#+NAME: set-player
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int set_player(t_data *data)
{
  int x;
  int y;

  if (!data)
    return (EXIT_FAILURE);
  y = 0;
  while (data->map->map[y])
  {
    x = 0;
    while (data->map->map[y][x])
    {
      if (ft_isinset(data->map->map[y][x], "NWSE"))
      {
	data->player->x = x;
	data->player->y = y;
	data->player->direction = data->map->map[y][x];
      }
      x++;
    }
    y++;
  }
  return (EXIT_SUCCESS);
}
#+END_SRC

*** TODO validating the data structure
+ [7/7] CHECKLIST
  + [X] invalid map characters (* != [0, 1, N, S, E, W])
  + [X] missing player starting-position
  + [X] unclosed map
  + [X] missing textures path (eg: NO '' || WE '')
  + [X] missing textures variable (eg: missing [NO, WE, ..., F, C])
  + [X] missing RGB info (eg: F '' || F abc,200,1 || F ($VAR>255))
  + [X] texture file inaccessible

After having parsed the .cub map into a data structure, I need to
verify that the information contained in the map is valid. See the
checklist above, and implement each of these checks.

#+NAME: validate-data
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int validate_data(t_data *data)
{
  int i;

  i = -1;
  while (++i < 4)
    if (!data->map->textures[i] || access(data->map->textures[i], R_OK) == -1)
      return (EXIT_FAILURE);
  if (!data->map->fcolor || data->map->fcolor == -1)
     return (EXIT_FAILURE);
  if (!data->map->fcolor || data->map->fcolor == -1)
     return (EXIT_FAILURE);
  if (validate_map(data->map, data) == EXIT_FAILURE)
    return (EXIT_FAILURE);
  return (EXIT_SUCCESS);
}
#+END_SRC

Now for validating the map. The fct takes in the map, and returns an
int on success or failure. It needs to check for:
 1) invalid pointers
 2) invalid characters missing characters
 3) unclosed map

#+NAME: validate-map
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int validate_map(t_map *map, t_data *data)
{
  int y;
  int x;
  int player;

  player = 0;
  y = -1;
  while (map->map[++y])
  {
    x = -1;
    while (map->map[y][++x])
    {
      if (!ft_isinset(map->map[y][x], "01NWSE"))
	return (EXIT_FAILURE);
      if (ft_isinset(map->map[y][x], "NWSE"))
	player++;
    }
  }
  if (player != 1)
    return (EXIT_FAILURE);
  if (check_map_integrity(data) == EXIT_FAILURE)
    return (EXIT_FAILURE);
  return (EXIT_SUCCESS);
}
#+END_SRC

Aight, so fuck the flood fill algorithm; it's a dumb way of checking
this. Let's do it iteratively. This algo's simple, and works for
pretty much every map error edge case (credits: mleblanc@42Quebec).

#+NAME: check-map-integrity
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int check_axis(t_data *data, int x, int y)
{
  int i;
  int j;
  int axis;

  i = x;
  j = y;
  axis = 0;
  while (x >= 0)
  {
    if (data->map->map[y][x] == '1')
    {
      axis++;
      break ;
    }
    x--;
  }
  x = i;
  y = j;
  while (x < data->map->width)
  {
    if (data->map->map[y][x] == '1')
    {
      axis++;
      break ;
    }
    x++;
  }
  x = i;
  y = j;
  while (y >= 0)
  {
    if (data->map->map[y][x] == '1')
    {
      axis++;
      break ;
    }
    y--;
  }
  x = i;
  y = j;
  while (y < data->map->height)
  {
    if (data->map->map[y][x] == '1')
    {
      axis++;
      break ;
    }
    y++;
  }
  if (axis == 4)
    return (EXIT_SUCCESS);
  return (EXIT_FAILURE);
}

int check_map_integrity(t_data *data)
{
  int x;
  int y;

  y = 0;
  while (y < data->map->height)
  {
    x = 0;
    while (x < data->map->width)
    {
      if (ft_isinset(data->map->map[y][x], "0NWSE"))
	if (check_axis(data, x, y) == EXIT_FAILURE)
	  return (EXIT_FAILURE);
      x++;
    }
    y++;
  }
  return (EXIT_SUCCESS);
}
#+END_SRC

** [0/1] rendering
Raycasting simulates a 3d perspective in a 2d map. The idea is to take
the position of the player and the direction it is looking in, and
calculate how far walls are from it. When we have found that, we can
render the walls according to their distance from the player by doing
some math. Basically, we'll implement that using a DDA algorithm.

There's also some math stuff about planes, cameras, vectors, and
matrix multiplication.

*** DDA Algorithm
Stuff about DDA.

** [3/5] utils
*** DONE window management
#+NAME: destroy-window
#+HEADER: :exports code :mkdirp yes :results none :main no
#+BEGIN_SRC C
int destroy_window(t_data *data)
{
  mlx_destroy_window(data->mlx, data->window);
  data->window = NULL;
  exit(0);
  return (0);
}
#+END_SRC
*** TODO memory cleanup
This is how I free memory alloc'd during the program. 

#+NAME: memory-cleanup
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
void memclean(t_data *data)
{
  int i;

  if (!data)
    return ;
  i = -1;
  while (++i < 4)
	 free(data->map->textures[i]);
  free(data->map->textures);
  if (data->map->map)
    ft_free_carray(data->map->map);
  free(data->map);
  free(data->player);
  destroy_window(data);
  free(data->mlx);
  free(data);
}
#+END_SRC
*** DONE color conversion
We're receiving colors in a char**: ["F", "255", "255", "255"]. This
can be represented as an integer with a bit of type conversion and a
simple bitshifting operation.

Info on transparency was very sparse. It does the same thing as RGBA,
but in a different manner. For minilibx, we are forced to use TRGB;
assume (T=0) == opaque.

#+NAME: convert-to-rgb
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
int convert_to_rgb(char *r, char *g, char *b)
{
  int trgb[4];
  int i;
  
  if (!r | !g | !b)
    return (-1);
  if (!ft_isint(r) || !ft_isint(g) || !ft_isint(b))
    return (-1);
  trgb[0] = 0;
  trgb[1] = ft_atoi(r);
  trgb[2] = ft_atoi(g);
  trgb[3] = ft_atoi(b);
  i = -1;
  while (++i < 4)
    if (trgb[i] > 255 || trgb[i] < 0)
      return (-1);
  return (trgb[0] << 24 | trgb[1] << 16 | trgb[2] << 8 | trgb[3]);
}
#+END_SRC
*** DONE print structure
#+NAME: print-structure
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
void print_structure(t_data *data)
{
  int i;
  int x;
  int y;

  i = -1;
  printf("===\tCub3D\t===\n");
  printf("===\tAssets\t===\n");
  while (++i < 4)
    printf("%d. %s\n", i, data->map->textures[i]);
  printf("\n===\tColors\t===\n");
  printf("F: %d C: %d\n", data->map->fcolor, data->map->ccolor);
  y = 0;
  printf("\n===\tMap\t===\n");
  printf("width: %d, height: %d\n\n", data->map->width, data->map->height);
  while (data->map->map[y])
  {
    x = 0;
    while (data->map->map[y][x])
    {
      printf("%c", data->map->map[y][x]);
      x++;
    }
    printf("\n");
    y++;
  }
  printf("\n===\tPlayer\t===\n");
  printf("(%d, %d), direction: %c\n", data->player->x, data->player->y, data->player->direction);
  printf("\n===================\n");
  return ;
}
#+END_SRC
*** TODO better wall syntax
#+NAME: get-wall
#+HEADER: :exports code
#+HEADER: :main no :noweb yes
#+BEGIN_SRC C
char *get_wall(int index)
{
  if (index == 0)
    return ("NO");
  if (index == 1)
    return ("WE");
  if (index == 2)
    return ("SO");
  if (index == 3)
    return ("EA");
  return (NULL);
}
#+END_SRC
* Source Code
A collection of all source files compiled from src-blocks above.

** main.c
#+NAME: main.c
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+HEADER: :tangle Source/main.c
#+BEGIN_SRC C
#include "includes/cub3d.h"

<<init-struct>>

<<memory-cleanup>>

int main(int argc, char **argv)
{
  <<initial-error>>
  <<parser-start>>
  <<hook-setup>>
}
#+END_SRC

** keypress.c
#+NAME: keypress.c
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+HEADER: :tangle Source/keypress.c
#+BEGIN_SRC C
#include "includes/cub3d.h"

<<handle-keypress>>
#+END_SRC

#+RESULTS: keypress.c

** parser.c
#+NAME: parser.c
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+HEADER: :tangle Source/parse.c
#+BEGIN_SRC C
#include "includes/cub3d.h"

<<set-player>>

<<is-map>>

<<fill-line>>

<<find-longest-line>>

<<calculate-dimensions>>

<<parse-map>>

<<check-filepath>>

<<read-file>>

<<tokenize>>

<<set-tokens>>

<<forge-structure>>

<<check-map-integrity>>

<<validate-map>>

<<validate-data>>

<<setup-mlx>>

<<parser>>
#+END_SRC
** utils.c
#+NAME: utils.c
#+HEADER: :exports code :mkdirp yes
#+HEADER: :main no :noweb yes
#+HEADER: :tangle Source/utils.c
#+BEGIN_SRC C
#include "includes/cub3d.h"

<<destroy-window>>

<<convert-to-rgb>>

<<print-structure>>

<<get-wall>>
#+END_SRC

